Index: frmts/jp2kak/makefile.vc
===================================================================
--- frmts/jp2kak/makefile.vc	(revision 13566)
+++ frmts/jp2kak/makefile.vc	(working copy)
@@ -1,17 +1,34 @@
-
 GDAL_ROOT	=	..\..
 
 !INCLUDE $(GDAL_ROOT)\nmake.opt
 
 OBJ	=	jp2kakdataset.obj
-EXTRAFLAGS = 	-I$(KAKDIR) /DKDU_PENTIUM_MSVC /GX
 
+EXTRAFLAGS = 	-I$(KAKDIR) -I$(KAKDIR)\coresys\common -I$(KAKDIR)\apps\compressed_io \
+	-I$(KAKDIR)\apps\jp2 -I$(KAKDIR)\apps\image -I$(KAKDIR)\apps\args -I$(KAKDIR)\apps\support  /DKDU_PENTIUM_MSVC /GX
+
+APPOBJ  = $(KAKDIR)\apps\make\args.obj $(KAKDIR)\apps\make\image_in.obj \
+	$(KAKDIR)\apps\make\image_out.obj $(KAKDIR)\apps\make\jp2.obj \
+	$(KAKDIR)\apps\make\mj2.obj $(KAKDIR)\apps\make\palette.obj \
+	$(KAKDIR)\apps\make\roi_sources.obj
+
+# The following are just for Kakadu 5.1 or later.
+APPOBJ = $(KAKDIR)/apps/make/kdu_tiff.obj $(KAKDIR)/apps/make/jpx.obj $(KAKDIR)/apps/make/kdu_stripe_decompressor.obj $APPOBJ
+
 default:	$(OBJ) kakinstall
-	xcopy /D  /Y *.obj ..\o
+	copy *.obj ..\o
 
 kakinstall:
-	copy $(KAKDIR)\*.obj ..\o
+	copy $(KAKDIR)\apps\make\args.obj ..\o
+	copy $(KAKDIR)\apps\make\image_in.obj ..\o
+	copy $(KAKDIR)\apps\make\image_out.obj ..\o
+	copy $(KAKDIR)\apps\make\jp2.obj ..\o
+	copy $(KAKDIR)\apps\make\mj2.obj ..\o
+	copy $(KAKDIR)\apps\make\palette.obj ..\o
+	copy $(KAKDIR)\apps\make\roi_sources.obj ..\o
+	copy $(KAKDIR)\apps\make\kdu_tiff.obj ..\o
+	copy $(KAKDIR)\apps\make\jpx.obj ..\o
+	copy $(KAKDIR)\apps\make\kdu_stripe_decompressor.obj ..\o
 
 clean:
 	-del *.obj
-
Index: frmts/jp2kak/jp2kakdataset.cpp
===================================================================
--- frmts/jp2kak/jp2kakdataset.cpp	(revision 13566)
+++ frmts/jp2kak/jp2kakdataset.cpp	(working copy)
@@ -39,6 +39,7 @@
 #include "kdu_params.h"
 #include "kdu_compressed.h"
 #include "kdu_sample_processing.h"
+#include "kdu_stripe_decompressor.h"
 
 #ifdef FILEIO_DEBUG
 #include "dbg_file_source.h"
@@ -60,14 +61,14 @@
 #  ifdef JP2_COMPRESSION_TYPE_NONE
 #    define KAKADU41
 #  endif
-#endif									
+#endif
 
 #if defined(KAKADU4) && defined(WIN32) && !defined(KAKADU41)
 #  define USE_JPIP
 #endif
 
 #ifdef USE_JPIP
-#  include "kdu_client.h" 
+#  include "kdu_client.h"
 #else
 #  define kdu_client void
 #endif
@@ -75,11 +76,11 @@
 CPL_CVSID("$Id$");
 
 CPL_C_START
-CPLErr CPL_DLL GTIFMemBufFromWkt( const char *pszWKT, 
+CPLErr CPL_DLL GTIFMemBufFromWkt( const char *pszWKT,
                                   const double *padfGeoTransform,
                                   int nGCPCount, const GDAL_GCP *pasGCPList,
                                   int *pnSize, unsigned char **ppabyBuffer );
-CPLErr CPL_DLL GTIFWktFromMemBuf( int nSize, unsigned char *pabyBuffer, 
+CPLErr CPL_DLL GTIFWktFromMemBuf( int nSize, unsigned char *pabyBuffer,
                           char **ppszWKT, double *padfGeoTransform,
                           int *pnGCPCount, GDAL_GCP **ppasGCPList );
 CPL_C_END
@@ -90,10 +91,10 @@
 transfer_bytes(kdu_byte *dest, kdu_line_buf &src, int gap, int precision,
                GDALDataType eOutType );
 
-static unsigned char jp2_header[] = 
+static unsigned char jp2_header[] =
 {0x00,0x00,0x00,0x0c,0x6a,0x50,0x20,0x20,0x0d,0x0a,0x87,0x0a};
 
-static unsigned char jpc_header[] = 
+static unsigned char jpc_header[] =
 {0xff,0x4f};
 
 
@@ -105,6 +106,7 @@
 
 class JP2KAKDataset : public GDALPamDataset
 {
+	friend class JP2KAKRasterBand;
     kdu_codestream oCodeStream;
     kdu_compressed_source *poInput;
     kdu_compressed_source *poRawInput;
@@ -112,7 +114,8 @@
     jp2_family_src  *family;
 #endif
     kdu_client      *jpip_client;
-    kdu_dims dims; 
+    kdu_dims dims;
+    int            nResCount;
 
     char	   *pszProjection;
     double	   adfGeoTransform[6];
@@ -123,10 +126,26 @@
 
     void           PamOverride();
 
+    int num_threads;
+
+	kdu_thread_env *pThread_env;
+
+	int         TestUseBlockIO( int, int, int, int, int, int,
+			GDALDataType, int, int * );
+		CPLErr      DirectRasterIO( GDALRWFlag, int, int, int, int,
+			void *, int, int, GDALDataType,
+			int, int *, int, int, int );
+
+		virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
+			void *, int, int, GDALDataType,
+		int, int *, int, int, int );
+
+	void prepareThreading();
+
   public:
                 JP2KAKDataset();
 		~JP2KAKDataset();
-    
+
     virtual CPLErr GetGeoTransform( double * );
     virtual const char *GetProjectionRef(void);
     virtual int    GetGCPCount();
@@ -149,9 +168,9 @@
 
     JP2KAKDataset *poBaseDS;
 
-    int         nDiscardLevels; 
+    int         nDiscardLevels;
 
-    kdu_dims 	band_dims; 
+    kdu_dims 	band_dims;
 
     int		nOverviewCount;
     JP2KAKRasterBand **papoOverviewBand;
@@ -163,15 +182,19 @@
     GDALColorTable oCT;
 
     int         bYCbCrReported;
-    
+
     GDALColorInterp eInterp;
 
+    virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
+			void *, int, int, GDALDataType,
+		int, int );
+
   public:
 
     		JP2KAKRasterBand( int, int, kdu_codestream, int, kdu_client *,
                                   jp2_channels, JP2KAKDataset * );
     		~JP2KAKRasterBand();
-    
+
     virtual CPLErr IReadBlock( int, int, void * );
 
     virtual int    GetOverviewCount();
@@ -183,7 +206,7 @@
     // internal
 
     void        ApplyPalette( jp2_palette oJP2Palette );
-    void        ProcessYCbCrTile(kdu_tile tile, GByte *pabyBuffer, 
+    void        ProcessYCbCrTile(kdu_tile tile, GByte *pabyBuffer,
                                  int nBlockXOff, int nBlockYOff,
                                  int nTileOffsetX, int nTileOffsetY );
     void        ProcessTile(kdu_tile tile, GByte *pabyBuffer );
@@ -195,10 +218,10 @@
 /* ==================================================================== */
 /************************************************************************/
 
-class kdu_cpl_error_message : public kdu_message 
+class kdu_cpl_error_message : public kdu_message
 {
 public: // Member classes
-    kdu_cpl_error_message( CPLErr eErrClass ) 
+    kdu_cpl_error_message( CPLErr eErrClass )
     {
         m_eErrClass = eErrClass;
         m_pszError = NULL;
@@ -210,7 +233,7 @@
             m_pszError = CPLStrdup( string );
         else
         {
-            m_pszError = (char *) 
+            m_pszError = (char *)
                 CPLRealloc(m_pszError, strlen(m_pszError) + strlen(string)+1 );
             strcat( m_pszError, string );
         }
@@ -220,7 +243,7 @@
     {
     };
 
-    void flush(bool end_of_message=false) 
+    void flush(bool end_of_message=false)
     {
         if( m_pszError == NULL )
             return;
@@ -293,7 +316,7 @@
         nBlockXSize = 2048;
     else
         nBlockXSize = nRasterXSize;
-    
+
     if( nRasterYSize >= 256 )
         nBlockYSize = 128;
     else
@@ -302,7 +325,7 @@
 /* -------------------------------------------------------------------- */
 /*      Figure out the color interpretation for this band.              */
 /* -------------------------------------------------------------------- */
-    
+
     eInterp = GCI_Undefined;
 
     if( oJP2Channels.exists() )
@@ -314,7 +337,7 @@
 
         if( oJP2Channels.get_num_colours() == 3 )
         {
-#ifdef KAKADU41 
+#ifdef KAKADU41
             oJP2Channels.get_colour_mapping( 0, nRedIndex, nLutIndex, nCSI );
             oJP2Channels.get_colour_mapping( 1, nGreenIndex, nLutIndex, nCSI );
             oJP2Channels.get_colour_mapping( 2, nBlueIndex, nLutIndex, nCSI );
@@ -326,7 +349,7 @@
         }
         else
         {
-#ifdef KAKADU41 
+#ifdef KAKADU41
             oJP2Channels.get_colour_mapping( 0, nRedIndex, nLutIndex, nCSI );
 #else
             oJP2Channels.get_colour_mapping( 0, nRedIndex, nLutIndex );
@@ -342,7 +365,7 @@
         else if( nLutIndex != -1 )
             eInterp = GCI_PaletteIndex;
 
-        // Establish color band this is. 
+        // Establish color band this is.
         else if( nRedIndex == nBand-1 )
             eInterp = GCI_RedBand;
         else if( nGreenIndex == nBand-1 )
@@ -357,10 +380,10 @@
         {
             int color_idx, opacity_idx, lut_idx;
 
-            for( color_idx = 0; 
+            for( color_idx = 0;
                  color_idx < oJP2Channels.get_num_colours(); color_idx++ )
             {
-#ifdef KAKADU41 
+#ifdef KAKADU41
                 if( oJP2Channels.get_opacity_mapping( color_idx, opacity_idx,
                                                       lut_idx, nCSI ) )
                 {
@@ -398,7 +421,7 @@
         eInterp = GCI_BlueBand;
     else
         eInterp = GCI_GrayIndex;
-        
+
 /* -------------------------------------------------------------------- */
 /*      Do we have any overviews?  Only check if we are the full res    */
 /*      image.                                                          */
@@ -427,10 +450,10 @@
                 && (dims.size.y == nYSize || dims.size.y == nYSize-1) )
             {
                 nOverviewCount++;
-                papoOverviewBand = (JP2KAKRasterBand **) 
-                    CPLRealloc( papoOverviewBand, 
+                papoOverviewBand = (JP2KAKRasterBand **)
+                    CPLRealloc( papoOverviewBand,
                                 sizeof(void*) * nOverviewCount );
-                papoOverviewBand[nOverviewCount-1] = 
+                papoOverviewBand[nOverviewCount-1] =
                     new JP2KAKRasterBand( nBand, nDiscard, oCodeStream, 0,
                                           jpip_client, oJP2Channels,
                                           poBaseDS );
@@ -438,7 +461,7 @@
             else
             {
                 CPLDebug( "GDAL", "Discard %dx%d JPEG2000 overview layer,\n"
-                          "expected %dx%d.", 
+                          "expected %dx%d.",
                           dims.size.x, dims.size.y, nXSize, nYSize );
             }
         }
@@ -488,6 +511,9 @@
 CPLErr JP2KAKRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,
                                       void * pImage )
 {
+	CPLDebug( "JP2KAK", "IReadBlock(%d,%d) on band %d.",
+		nBlockXOff, nBlockYOff, nBand );
+
     try
     {
 /* -------------------------------------------------------------------- */
@@ -499,12 +525,12 @@
         dims.pos.y = dims.pos.y + nBlockYOff * nBlockYSize;
         dims.size.x = nBlockXSize;
         dims.size.y = nBlockYSize;
-    
+
         kdu_dims dims_roi;
 
         oCodeStream.apply_input_restrictions( 0, 0, nDiscardLevels, 0, NULL );
         oCodeStream.map_region( 0, dims, dims_roi );
-        oCodeStream.apply_input_restrictions( 0, 0, nDiscardLevels, 0, 
+        oCodeStream.apply_input_restrictions( 0, 0, nDiscardLevels, 0,
                                               &dims_roi );
 
 /* -------------------------------------------------------------------- */
@@ -526,38 +552,52 @@
 
             while( !jpip_client->is_idle() )
                 CPLSleep( 0.25 );
-            
+
             if( !jpip_client->is_alive() )
             {
-                CPLError( CE_Failure, CPLE_AppDefined, 
+                CPLError( CE_Failure, CPLE_AppDefined,
                           "JPIP failure some time after post_window()." );
                 return CE_Failure;
             }
         }
 #endif
-    
+
 /* -------------------------------------------------------------------- */
 /*      Now we are ready to walk through the tiles processing them      */
 /*      one-by-one.                                                     */
 /* -------------------------------------------------------------------- */
-        kdu_dims tile_indices; 
+        kdu_dims tile_indices;
         kdu_coords tpos;
         int  nWordSize = GDALGetDataTypeSize( eDataType ) / 8;
-    
+
         oCodeStream.get_valid_tiles(tile_indices);
-    
+
+        /* -------------------------------------------------------------------- */
+		/*      Multithreading Management                                       */
+		/* -------------------------------------------------------------------- */
+		poBaseDS->prepareThreading();
+
+		/* -------------------------------------------------------------------- */
+		/*      Core loop				                                        */
+		/* -------------------------------------------------------------------- */
+
         for (tpos.y=0; tpos.y < tile_indices.size.y; tpos.y++)
         {
             for (tpos.x=0; tpos.x < tile_indices.size.x; tpos.x++)
             {
-                kdu_tile tile = oCodeStream.open_tile(tpos+tile_indices.pos);
+				//open up a tile
+				kdu_tile tile = oCodeStream.open_tile(
+					tpos+tile_indices.pos,
+					poBaseDS->num_threads>1?poBaseDS->pThread_env :NULL);
+				//get a particular resolution level and acquire the dimension
+				//of that particular level
 
-                kdu_resolution res = 
+                kdu_resolution res =
                     tile.access_component(0).access_resolution();
                 kdu_dims tile_dims; res.get_dims(tile_dims);
                 kdu_coords offset = tile_dims.pos - dims.pos;
 
-                try 
+                try
                 {
                     if( tile.get_ycc() && nBand < 4 )
                         ProcessYCbCrTile( tile, (GByte *) pImage,
@@ -566,17 +606,17 @@
                     else
                     {
                         GByte *pabyDest;
-                        
-                        pabyDest = ((GByte *)pImage) 
+
+                        pabyDest = ((GByte *)pImage)
                             + (offset.x + offset.y*nBlockXSize) * nWordSize;
 
                         ProcessTile( tile, pabyDest );
                     }
-                    tile.close();
+                    tile.close(poBaseDS->num_threads>1?poBaseDS->pThread_env :NULL);
                 }
                 catch( ... )
                 {
-                    tile.close();
+                    tile.close(poBaseDS->num_threads>1?poBaseDS->pThread_env :NULL);
                     return CE_Failure;
                 }
 
@@ -607,40 +647,47 @@
     // Open tile-components and create processing engines and resources
     kdu_dims dims;
     kdu_sample_allocator allocator;
+    //we work an per band basis here...
     kdu_tile_comp comp = tile.access_component(nBand-1);
     kdu_line_buf line;
     kdu_pull_ifc engine;
     bool reversible = comp.get_reversible();
     int bit_depth = comp.get_bit_depth();
+    //acquire the HIGHEST resolution level for this tile component
     kdu_resolution res = comp.access_resolution();
     int  nWordSize = GDALGetDataTypeSize( eDataType ) / 8;
+	//get the dimension of the acquired resolution level
+    res.get_dims(dims);
 
-    res.get_dims(dims);
-    
     bool use_shorts = (comp.get_bit_depth(true) <= 16);
-
+	bool useMT=poBaseDS->num_threads>1&&poBaseDS->pThread_env&&poBaseDS->pThread_env->exists();
+	//precreate the  line buffer
     line.pre_create(&allocator,dims.size.x,reversible,use_shorts);
 
     if (res.which() == 0) // No DWT levels used
-        engine =
-            kdu_decoder(res.access_subband(LL_BAND),&allocator,use_shorts);
-    else
-        engine = kdu_synthesis(res,&allocator,use_shorts);
+		engine =
+		kdu_decoder(res.access_subband(LL_BAND),&allocator,use_shorts,1.0F,0,useMT?poBaseDS->pThread_env:NULL);
+	else
+		engine = kdu_synthesis(res,&allocator,use_shorts,1.0F,useMT?poBaseDS->pThread_env:NULL);
 
     allocator.finalize(); // Actually creates buffering resources
 
     line.create(); // Grabs resources from the allocator.
+	//start as soon as possible with background processing
+	engine.start(useMT?poBaseDS->pThread_env:NULL);
 
     // Now walk through the lines of the buffer, recovering them from the
     // relevant tile-component processing engines.
 
     for( int y = 0; y < dims.size.y; y++ )
     {
-        engine.pull(line,true);
+        engine.pull(line,useMT?poBaseDS->pThread_env :NULL);
         transfer_bytes(pabyDest + y * nBlockXSize * nWordSize,
                        line, nWordSize, bit_depth, eDataType );
     }
 
+	if(useMT)
+		poBaseDS->pThread_env->synchronize(NULL);
     engine.destroy();
 }
 
@@ -652,7 +699,7 @@
 /*      into the working buffer.                                        */
 /************************************************************************/
 
-void JP2KAKRasterBand::ProcessYCbCrTile( kdu_tile tile, GByte *pabyDest, 
+void JP2KAKRasterBand::ProcessYCbCrTile( kdu_tile tile, GByte *pabyDest,
                                          int nBlockXOff, int nBlockYOff,
                                          int nTileOffsetX, int nTileOffsetY )
 
@@ -706,7 +753,7 @@
 
                 for( iOver = 0; iOver < poBaseBand->GetOverviewCount(); iOver++ )
                 {
-                    poBand = (JP2KAKRasterBand *) 
+                    poBand = (JP2KAKRasterBand *)
                         poBaseBand->GetOverview( iOver );
                     if( poBand->nDiscardLevels == nDiscardLevels )
                         break;
@@ -718,7 +765,7 @@
                 }
             }
 
-            apoBlocks[iBand] = 
+            apoBlocks[iBand] =
                 poBand->GetLockedBlockRef( nBlockXOff, nBlockYOff, TRUE );
             apabyBandDest[iBand] = (GByte *) apoBlocks[iBand]->GetDataRef();
         }
@@ -728,8 +775,9 @@
 /*      Setup decoders.                                                 */
 /* -------------------------------------------------------------------- */
     res.get_dims(dims);
-    
+
     bool use_shorts = (comp[0].get_bit_depth(true) <= 16);
+    bool useMT=poBaseDS->num_threads>1&&poBaseDS->pThread_env&&poBaseDS->pThread_env->exists();
 
     for( iComp = 0; iComp < 3; iComp++ )
     {
@@ -737,17 +785,21 @@
 
         if (res.which() == 0) // No DWT levels used
             engine[iComp] =
-                kdu_decoder(comp[iComp].access_resolution().access_subband(LL_BAND),
-                            &allocator,use_shorts);
+            kdu_decoder(comp[iComp].access_resolution().access_subband(LL_BAND),
+			&allocator,use_shorts,1.0F,0,useMT?poBaseDS->pThread_env:NULL);
         else
-            engine[iComp] = 
-                kdu_synthesis(comp[iComp].access_resolution(),&allocator,use_shorts);
+            engine[iComp] =
+            kdu_synthesis(comp[iComp].access_resolution(),&allocator,use_shorts,1.0F,
+			useMT?poBaseDS->pThread_env:NULL);
     }
 
     allocator.finalize(); // Actually creates buffering resources
 
     for( iComp = 0; iComp < 3; iComp++ )
         line[iComp].create(); // Grabs resources from the allocator.
+        //start MT as soon as possible
+		if(useMT)
+			engine[iComp].start(poBaseDS->pThread_env);
 
 /* -------------------------------------------------------------------- */
 /*      Now walk through the lines of the buffer, recovering them from the*/
@@ -756,22 +808,34 @@
 
     for( int y = 0; y < dims.size.y; y++ )
     {
-        engine[0].pull(line[0],true);
-        engine[1].pull(line[1],true);
-        engine[2].pull(line[2],true);
+       	if(!useMT)
+		{
+			engine[0].pull(line[0],true);
+			engine[1].pull(line[1],true);
+			engine[2].pull(line[2],true);
+		}
+		else
+		{
+			engine[0].pull(line[0],poBaseDS->pThread_env);
+			engine[1].pull(line[1],poBaseDS->pThread_env);
+			engine[2].pull(line[2],poBaseDS->pThread_env);
+		}
 
         kdu_convert_ycc_to_rgb(line[0], line[1], line[2]);
 
         for( iBand = 0; iBand < 3; iBand++ )
-            transfer_bytes(apabyBandDest[iBand] 
-                           + (nTileOffsetX+nTileOffsetY*nBlockXSize)*nWordSize,
+            transfer_bytes(apabyBandDest[iBand]
+                           + (nTileOffsetX+(nTileOffsetY+y)*nBlockXSize)*nWordSize,
                            line[iBand], nWordSize, bit_depth, eDataType );
     }
 
 /* -------------------------------------------------------------------- */
 /*      Cleanup and release band locks.                                 */
 /* -------------------------------------------------------------------- */
-    engine[0].destroy();
+ 	if(useMT)
+		poBaseDS->pThread_env->synchronize(NULL);
+
+   	engine[0].destroy();
     engine[1].destroy();
     engine[2].destroy();
 
@@ -783,6 +847,38 @@
 }
 
 /************************************************************************/
+/*                             IRasterIO()                              */
+/************************************************************************/
+
+CPLErr
+JP2KAKRasterBand::IRasterIO( GDALRWFlag eRWFlag,
+							int nXOff, int nYOff, int nXSize, int nYSize,
+							void * pData, int nBufXSize, int nBufYSize,
+							GDALDataType eBufType,
+							int nPixelSpace,int nLineSpace )
+
+{
+	/* -------------------------------------------------------------------- */
+	/*      We need various criteria to skip out to block based methods.    */
+	/* -------------------------------------------------------------------- */
+	if( poBaseDS->TestUseBlockIO( nXOff, nYOff, nXSize, nYSize,
+		nBufXSize, nBufYSize,
+		eBufType, 1, &nBand ) )
+		return GDALPamRasterBand::IRasterIO(
+		eRWFlag, nXOff, nYOff, nXSize, nYSize,
+		pData, nBufXSize, nBufYSize, eBufType,
+		nPixelSpace, nLineSpace );
+	else
+		return poBaseDS->DirectRasterIO(
+		eRWFlag, nXOff, nYOff, nXSize, nYSize,
+		pData, nBufXSize, nBufYSize, eBufType,
+		1, &nBand, nPixelSpace, nLineSpace, 0 );
+}
+
+
+
+
+/************************************************************************/
 /*                            ApplyPalette()                            */
 /************************************************************************/
 
@@ -801,7 +897,7 @@
     if( oJP2Palette.get_num_luts() < 3 )
     {
         CPLDebug( "JP2KAK", "JP2KAKRasterBand::ApplyPalette()\n"
-                  "Odd get_num_luts() value (%d)", 
+                  "Odd get_num_luts() value (%d)",
                   oJP2Palette.get_num_luts() );
         return;
     }
@@ -830,7 +926,7 @@
             pafLUT[nCount*3 + iColor] = 0.5;
         }
     }
-    
+
 /* -------------------------------------------------------------------- */
 /*      Apply to GDAL colortable.                                       */
 /* -------------------------------------------------------------------- */
@@ -903,6 +999,8 @@
     adfGeoTransform[3] = 0.0;
     adfGeoTransform[4] = 0.0;
     adfGeoTransform[5] = 1.0;
+    num_threads=1;
+	pThread_env=NULL;
 }
 
 /************************************************************************/
@@ -915,13 +1013,23 @@
     FlushCache();
 
     CPLFree( pszProjection );
-    
+
     if( nGCPCount > 0 )
     {
         GDALDeinitGCPs( nGCPCount, pasGCPList );
         CPLFree( pasGCPList );
     }
 
+    /************************************************************************/
+	/* Handling multithreading shutdown  nicely                             */
+	/************************************************************************/
+	if(pThread_env)
+	{
+		if(pThread_env->exists())
+			pThread_env->destroy();
+		delete pThread_env;
+	}
+
     if( poInput != NULL )
     {
         oCodeStream.destroy();
@@ -970,7 +1078,7 @@
     if( bGeoTransformValid )
     {
         memcpy( padfTransform, adfGeoTransform, sizeof(double)*6 );
-    
+
         return CE_None;
     }
     else
@@ -1026,7 +1134,7 @@
 
         kdu_cpl_error_message oErrHandler( CE_Failure );
         kdu_cpl_error_message oWarningHandler( CE_Warning );
-        
+
         kdu_customize_warnings(new kdu_cpl_error_message( CE_Warning ) );
         kdu_customize_errors(new kdu_cpl_error_message( CE_Failure ) );
     }
@@ -1039,191 +1147,191 @@
 GDALDataset *JP2KAKDataset::Open( GDALOpenInfo * poOpenInfo )
 
 {
-    subfile_source *poRawInput = NULL;
-    const char  *pszExtension = NULL;
-    int         bIsJPIP = FALSE;
-    int         bIsSubfile = FALSE;
-    GByte      *pabyHeader = NULL;
+	subfile_source *poRawInput = NULL;
+	const char  *pszExtension = NULL;
+	int         bIsJPIP = FALSE;
+	int         bIsSubfile = FALSE;
+	GByte      *pabyHeader = NULL;
 
-/* -------------------------------------------------------------------- */
-/*      Check header                                                    */
-/* -------------------------------------------------------------------- */
-    if( poOpenInfo->fp == NULL )
-    {
-        pszExtension = CPLGetExtension( poOpenInfo->pszFilename );
-        if( (EQUALN(poOpenInfo->pszFilename,"http://",7)
-             || EQUALN(poOpenInfo->pszFilename,"https://",8)
-             || EQUALN(poOpenInfo->pszFilename,"jpip://",7))
-            && EQUAL(pszExtension,"jp2") )
-        {
-            bIsJPIP = TRUE;
-        }
-        else if( EQUALN(poOpenInfo->pszFilename,"J2K_SUBFILE:",12) )
-        {
-            static GByte abySubfileHeader[16];
+	/* -------------------------------------------------------------------- */
+	/*      Check header                                                    */
+	/* -------------------------------------------------------------------- */
+	if( poOpenInfo->fp == NULL )
+	{
+		pszExtension = CPLGetExtension( poOpenInfo->pszFilename );
+		if( (EQUALN(poOpenInfo->pszFilename,"http://",7)
+			|| EQUALN(poOpenInfo->pszFilename,"https://",8)
+			|| EQUALN(poOpenInfo->pszFilename,"jpip://",7))
+			&& EQUAL(pszExtension,"jp2") )
+		{
+			bIsJPIP = TRUE;
+		}
+		else if( EQUALN(poOpenInfo->pszFilename,"J2K_SUBFILE:",12) )
+		{
+			static GByte abySubfileHeader[16];
 
-            KakaduInitialize();
-            try
-            {
-                poRawInput = new subfile_source( poOpenInfo->pszFilename );
-                poRawInput->seek( 0 );
+			KakaduInitialize();
+			try
+			{
+				poRawInput = new subfile_source( poOpenInfo->pszFilename );
+				poRawInput->seek( 0 );
 
-                poRawInput->read( abySubfileHeader, 16 );
-                poRawInput->seek( 0 );
-            }
-            catch( ... )
-            {
-                return NULL;
-            }
+				poRawInput->read( abySubfileHeader, 16 );
+				poRawInput->seek( 0 );
+			}
+			catch( ... )
+			{
+				return NULL;
+			}
 
-            pabyHeader = abySubfileHeader;
+			pabyHeader = abySubfileHeader;
 
-            bIsSubfile = TRUE;
-        }
-        else
-            return NULL;
-    }
-    else
-    {
-        if( poOpenInfo->nHeaderBytes < 16 )
-            return NULL;
+			bIsSubfile = TRUE;
+		}
+		else
+			return NULL;
+	}
+	else
+	{
+		if( poOpenInfo->nHeaderBytes < 16 )
+			return NULL;
 
-        pabyHeader = poOpenInfo->pabyHeader;
-    }
+		pabyHeader = poOpenInfo->pabyHeader;
+	}
 
-/* -------------------------------------------------------------------- */
-/*      Any extension is supported for JP2 files.  Only selected        */
-/*      extensions are supported for JPC files since the standard       */
-/*      prefix is so short (two bytes).                                 */
-/* -------------------------------------------------------------------- */
-    if( !bIsJPIP )
-    {
-        if( memcmp(pabyHeader,jp2_header,sizeof(jp2_header)) == 0 )
-            pszExtension = "jp2";
-        else if( memcmp( pabyHeader, jpc_header, sizeof(jpc_header) ) == 0 )
-        {
-            pszExtension = CPLGetExtension( poOpenInfo->pszFilename );
-            if( !EQUAL(pszExtension,"jpc") && !EQUAL(pszExtension,"j2k") 
-                && !EQUAL(pszExtension,"jp2") && !EQUAL(pszExtension,"jpx") 
-                && !EQUAL(pszExtension,"j2c") )
-                pszExtension = "jpc";
-        }
-        else
-            return NULL;
-    }
+	/* -------------------------------------------------------------------- */
+	/*      Any extension is supported for JP2 files.  Only selected        */
+	/*      extensions are supported for JPC files since the standard       */
+	/*      prefix is so short (two bytes).                                 */
+	/* -------------------------------------------------------------------- */
+	if( !bIsJPIP )
+	{
+		if( memcmp(pabyHeader,jp2_header,sizeof(jp2_header)) == 0 )
+			pszExtension = "jp2";
+		else if( memcmp( pabyHeader, jpc_header, sizeof(jpc_header) ) == 0 )
+		{
+			pszExtension = CPLGetExtension( poOpenInfo->pszFilename );
+			if( !EQUAL(pszExtension,"jpc") && !EQUAL(pszExtension,"j2k")
+				&& !EQUAL(pszExtension,"jp2") && !EQUAL(pszExtension,"jpx")
+				&& !EQUAL(pszExtension,"j2c") )
+				pszExtension = "jpc";
+		}
+		else
+			return NULL;
+	}
 
-    KakaduInitialize();
-        
-/* -------------------------------------------------------------------- */
-/*      Try to open the file in a manner depending on the extension.    */
-/* -------------------------------------------------------------------- */
-    kdu_compressed_source *poInput = NULL;
-    kdu_client      *jpip_client = NULL;
-    jp2_palette oJP2Palette;
-    jp2_channels oJP2Channels;
+	KakaduInitialize();
 
+	/* -------------------------------------------------------------------- */
+	/*      Try to open the file in a manner depending on the extension.    */
+	/* -------------------------------------------------------------------- */
+	kdu_compressed_source *poInput = NULL;
+	kdu_client      *jpip_client = NULL;
+	jp2_palette oJP2Palette;
+	jp2_channels oJP2Channels;
+
 #ifdef KAKADU4
-    jp2_family_src *family = NULL;
+	jp2_family_src *family = NULL;
 #endif
 
-    try
-    {
-        if( bIsJPIP )
-        {
+	try
+	{
+		if( bIsJPIP )
+		{
 #ifdef USE_JPIP
-            jp2_source *jp2_src;
-            char *pszWrk = CPLStrdup(strstr(poOpenInfo->pszFilename,"://")+3);
-            char *pszRequest = strstr(pszWrk,"/");
-     
-            if( pszRequest == NULL )
-            {
-                CPLDebug( "JP2KAK", 
-                          "Failed to parse JPIP server and request." );
-                CPLFree( pszWrk );
-                return NULL;
-            }
+			jp2_source *jp2_src;
+			char *pszWrk = CPLStrdup(strstr(poOpenInfo->pszFilename,"://")+3);
+			char *pszRequest = strstr(pszWrk,"/");
 
-            *(pszRequest++) = '\0';
+			if( pszRequest == NULL )
+			{
+				CPLDebug( "JP2KAK",
+					"Failed to parse JPIP server and request." );
+				CPLFree( pszWrk );
+				return NULL;
+			}
 
-            CPLDebug( "JP2KAK", "server=%s, request=%s", 
-                      pszWrk, pszRequest );
+			*(pszRequest++) = '\0';
 
-            CPLSleep( 15.0 );
-            jpip_client = new kdu_client;
-            jpip_client->connect( pszWrk, NULL, pszRequest, "http-tcp", 
-                                  "" );
-            
-            CPLDebug( "JP2KAK", "After connect()" );
+			CPLDebug( "JP2KAK", "server=%s, request=%s",
+				pszWrk, pszRequest );
 
-            bool bin0_complete = false;
+			CPLSleep( 15.0 );
+			jpip_client = new kdu_client;
+			jpip_client->connect( pszWrk, NULL, pszRequest, "http-tcp",
+				"" );
 
-            while( jpip_client->get_databin_length(KDU_META_DATABIN,0,0,
-                                                   &bin0_complete) <= 0 
-                   || !bin0_complete )
-                CPLSleep( 0.25 );
+			CPLDebug( "JP2KAK", "After connect()" );
 
-            family = new jp2_family_src;
-            family->open( jpip_client );
+			bool bin0_complete = false;
 
-            jp2_src = new jp2_source;
-            jp2_src->open( family );
-            jp2_src->read_header();
+			while( jpip_client->get_databin_length(KDU_META_DATABIN,0,0,
+				&bin0_complete) <= 0
+				|| !bin0_complete )
+				CPLSleep( 0.25 );
 
-            while( !jpip_client->is_idle() )
-                CPLSleep( 0.25 );
+			family = new jp2_family_src;
+			family->open( jpip_client );
 
-            if( jpip_client->is_alive() )
-                CPLDebug( "JP2KAK", "connect() seems to be complete." );
-            else
-            {
-                CPLDebug( "JP2KAK", "connect() seems to have failed." );
-                return NULL;
-            }
+			jp2_src = new jp2_source;
+			jp2_src->open( family );
+			jp2_src->read_header();
 
-            oJP2Channels = jp2_src->access_channels();
+			while( !jpip_client->is_idle() )
+				CPLSleep( 0.25 );
 
-            poInput = jp2_src;
+			if( jpip_client->is_alive() )
+				CPLDebug( "JP2KAK", "connect() seems to be complete." );
+			else
+			{
+				CPLDebug( "JP2KAK", "connect() seems to have failed." );
+				return NULL;
+			}
+
+			oJP2Channels = jp2_src->access_channels();
+
+			poInput = jp2_src;
 #else
-            CPLError( CE_Failure, CPLE_OpenFailed, 
-                      "JPIP Protocol not supported by GDAL with Kakadu 3.4 or on Unix." );
+			CPLError( CE_Failure, CPLE_OpenFailed,
+				"JPIP Protocol not supported by GDAL with Kakadu 3.4 or on Unix." );
 #endif
-        }
-        else if( EQUAL(pszExtension,"jp2") || EQUAL(pszExtension,"jpx") )
-        {
-            jp2_source *jp2_src;
+		}
+		else if( EQUAL(pszExtension,"jp2") || EQUAL(pszExtension,"jpx") )
+		{
+			jp2_source *jp2_src;
 
 #ifdef KAKADU4
-            family = new jp2_family_src;
-            if( poRawInput != NULL )
-                family->open( poRawInput );
-            else
-                family->open( poOpenInfo->pszFilename, true );
-            jp2_src = new jp2_source;
-            jp2_src->open( family );
-            jp2_src->read_header();
+			family = new jp2_family_src;
+			if( poRawInput != NULL )
+				family->open( poRawInput );
+			else
+				family->open( poOpenInfo->pszFilename, true );
+			jp2_src = new jp2_source;
+			jp2_src->open( family );
+			jp2_src->read_header();
 #else
-            jp2_src = new jp2_source;
-            jp2_src->open( poOpenInfo->pszFilename, true );
+			jp2_src = new jp2_source;
+			jp2_src->open( poOpenInfo->pszFilename, true );
 #endif
-            poInput = jp2_src;
+			poInput = jp2_src;
 
-            oJP2Palette = jp2_src->access_palette();
-            oJP2Channels = jp2_src->access_channels();
-        }
-        else if( poRawInput == NULL )
-        {
+			oJP2Palette = jp2_src->access_palette();
+			oJP2Channels = jp2_src->access_channels();
+		}
+		else if( poRawInput == NULL )
+		{
 #ifndef FILEIO_DEBUG
-            poInput = new kdu_simple_file_source( poOpenInfo->pszFilename );
+			poInput = new kdu_simple_file_source( poOpenInfo->pszFilename );
 #else
-            poInput = new dbg_simple_file_source( poOpenInfo->pszFilename );
-#endif								       
-        }
-        else
-        {
-            poInput = poRawInput;
-            poRawInput = NULL;
-        }
-    }
+			poInput = new dbg_simple_file_source( poOpenInfo->pszFilename );
+#endif
+		}
+		else
+		{
+			poInput = poRawInput;
+			poRawInput = NULL;
+		}
+	}
     catch( ... )
     {
         CPLDebug( "JP2KAK", "Trapped Kakadu exception." );
@@ -1242,7 +1350,24 @@
         poDS->poInput = poInput;
         poDS->poRawInput = poRawInput;
         poDS->oCodeStream.create( poInput );
-        poDS->oCodeStream.set_fussy();
+
+        /************************************************************************/
+		/* Managing custom error level                                          */
+		/************************************************************************/
+		if( CPLGetConfigOption( "KAKADU_ERROR_LEVEL_MANAGEMENT", NULL ) != NULL )
+		{
+			const char *pszKduErrorManagement = CPLGetConfigOption( "KAKADU_ERROR_LEVEL_MANAGEMENT", "" );
+			if(EQUAL(pszKduErrorManagement,"FUSSY"))
+				poDS->oCodeStream.set_fussy();
+			else if (EQUAL(pszKduErrorManagement,"RESILIENT"))
+				poDS->oCodeStream.set_resilient();
+			else if (EQUAL(pszKduErrorManagement,"FAST"))
+				poDS->oCodeStream.set_fast();
+		}
+		else
+			poDS->oCodeStream.set_fussy();
+
+
 //        poDS->oCodeStream.set_resilient();
         poDS->oCodeStream.set_persistent();
 
@@ -1255,7 +1380,7 @@
 /*      Get overall image size.                                         */
 /* -------------------------------------------------------------------- */
         poDS->oCodeStream.get_dims( 0, poDS->dims );
-        
+
         poDS->nRasterXSize = poDS->dims.size.x;
         poDS->nRasterYSize = poDS->dims.size.y;
 
@@ -1266,13 +1391,13 @@
         poDS->nBands = poDS->oCodeStream.get_num_components();
 
         if (poDS->nBands > 1 )
-        { 
+        {
             int iDim;
-        
+
             for( iDim = 1; iDim < poDS->nBands; iDim++ )
             {
                 kdu_dims  dim_this_comp;
-            
+
                 poDS->oCodeStream.get_dims(iDim, dim_this_comp);
 
                 if( dim_this_comp != poDS->dims )
@@ -1289,7 +1414,7 @@
 /* -------------------------------------------------------------------- */
 /*      find out how many resolutions levels are available.             */
 /* -------------------------------------------------------------------- */
-        kdu_dims tile_indices; 
+        kdu_dims tile_indices;
         poDS->oCodeStream.get_valid_tiles(tile_indices);
 
         kdu_tile tile = poDS->oCodeStream.open_tile(tile_indices.pos);
@@ -1302,10 +1427,10 @@
 /*      Create band information objects.                                */
 /* -------------------------------------------------------------------- */
         int iBand;
-    
+
         for( iBand = 1; iBand <= poDS->nBands; iBand++ )
         {
-            JP2KAKRasterBand *poBand = 
+            JP2KAKRasterBand *poBand =
                 new JP2KAKRasterBand(iBand,0,poDS->oCodeStream, nResCount,
                                      jpip_client, oJP2Channels, poDS );
 
@@ -1321,12 +1446,12 @@
         if( poOpenInfo->fp != NULL )
         {
             GDALJP2Metadata oJP2Geo;
-        
+
             if( oJP2Geo.ReadAndParse( poOpenInfo->pszFilename ) )
             {
                 poDS->pszProjection = CPLStrdup(oJP2Geo.pszProjection);
                 poDS->bGeoTransformValid = TRUE;
-                memcpy( poDS->adfGeoTransform, oJP2Geo.adfGeoTransform, 
+                memcpy( poDS->adfGeoTransform, oJP2Geo.adfGeoTransform,
                         sizeof(double) * 6 );
                 poDS->nGCPCount = oJP2Geo.nGCPCount;
                 poDS->pasGCPList = oJP2Geo.pasGCPList;
@@ -1340,14 +1465,14 @@
 /* -------------------------------------------------------------------- */
             int iBox;
 
-            for( iBox = 0; 
+            for( iBox = 0;
                  oJP2Geo.papszGMLMetadata
-                     && oJP2Geo.papszGMLMetadata[iBox] != NULL; 
+                     && oJP2Geo.papszGMLMetadata[iBox] != NULL;
                  iBox++ )
             {
                 char *pszName = NULL;
-                const char *pszXML = 
-                    CPLParseNameValue( oJP2Geo.papszGMLMetadata[iBox], 
+                const char *pszXML =
+                    CPLParseNameValue( oJP2Geo.papszGMLMetadata[iBox],
                                        &pszName );
                 CPLString osDomain;
                 char *apszMDList[2];
@@ -1428,6 +1553,333 @@
 }
 
 /************************************************************************/
+/*                           DirectRasterIO()                           */
+/************************************************************************/
+
+CPLErr
+JP2KAKDataset::DirectRasterIO( GDALRWFlag eRWFlag,
+							  int nXOff, int nYOff, int nXSize, int nYSize,
+							  void * pData, int nBufXSize, int nBufYSize,
+							  GDALDataType eBufType,
+							  int nBandCount, int *panBandMap,
+							  int nPixelSpace,int nLineSpace,int nBandSpace)
+
+{
+	CPLAssert( eBufType == GDT_Byte );
+
+	/* -------------------------------------------------------------------- */
+	/*      Select optimal resolution level.                                */
+	/* -------------------------------------------------------------------- */
+	int nDiscardLevels = 0;
+	int nResMult = 1;
+
+	while( nDiscardLevels < nResCount - 1
+		&& nBufXSize * nResMult * 2 < nXSize * 1.01
+		&& nBufYSize * nResMult * 2 < nYSize * 1.01 )
+	{
+		nDiscardLevels++;
+		nResMult = nResMult * 2;
+	}
+
+	/* -------------------------------------------------------------------- */
+	/*      Prepare component indices list.                                 */
+	/* -------------------------------------------------------------------- */
+	CPLErr eErr=CE_None;
+	int *component_indices;
+	int *stripe_heights, *sample_offsets, *sample_gaps, *row_gaps;
+	int i;
+
+	component_indices = (int *) CPLMalloc(sizeof(int) * nBandCount);
+	stripe_heights = (int *) CPLMalloc(sizeof(int) * nBandCount);
+	sample_offsets = (int *) CPLMalloc(sizeof(int) * nBandCount);
+	sample_gaps = (int *) CPLMalloc(sizeof(int) * nBandCount);
+	row_gaps = (int *) CPLMalloc(sizeof(int) * nBandCount);
+
+	for( i = 0; i < nBandCount; i++ )
+		component_indices[i] = panBandMap[i] - 1;
+
+	/* -------------------------------------------------------------------- */
+	/*      Setup a ROI matching the block requested, and select desired    */
+	/*      bands (components).                                             */
+	/* -------------------------------------------------------------------- */
+	try
+	{
+		kdu_dims dims;
+		oCodeStream.apply_input_restrictions( 0, 0, nDiscardLevels, 0, NULL );
+		oCodeStream.get_dims( 0, dims );
+
+		dims.pos.x = dims.pos.x + nXOff/nResMult;
+		dims.pos.y = dims.pos.y + nYOff/nResMult;
+		dims.size.x = nXSize/nResMult;
+		dims.size.y = nYSize/nResMult;
+
+		kdu_dims dims_roi;
+
+		oCodeStream.map_region( 0, dims, dims_roi );
+		oCodeStream.apply_input_restrictions( nBandCount, component_indices,
+			nDiscardLevels, 0, &dims_roi,
+			KDU_WANT_CODESTREAM_COMPONENTS);
+
+		/* -------------------------------------------------------------------- */
+		/*      Multithreading Management                                       */
+		/* -------------------------------------------------------------------- */
+		prepareThreading();
+		bool useMT=num_threads>1&&pThread_env&&pThread_env->exists();
+
+		/* -------------------------------------------------------------------- */
+		/*      Special case where the data is being requested exactly at       */
+		/*      this resolution.  Avoid any extra sampling pass.                */
+		/* -------------------------------------------------------------------- */
+		if( nBufXSize == dims.size.x && nBufYSize == dims.size.y )
+		{
+
+			kdu_stripe_decompressor decompressor;
+			decompressor.start(oCodeStream,false,false,useMT?pThread_env:NULL);
+			CPLDebug( "JP2KAK", "DirectRasterIO() for %d,%d,%d,%d -> %dx%d (no intermediate)",
+				nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );
+
+			for( i = 0; i < nBandCount; i++ )
+			{
+				stripe_heights[i] = dims.size.y;
+				sample_offsets[i] = i * nBandSpace;
+				sample_gaps[i] = nPixelSpace;
+				row_gaps[i] = nLineSpace;
+			}
+
+			decompressor.pull_stripe( (kdu_byte *) pData, stripe_heights,
+				sample_offsets, sample_gaps, row_gaps );
+			decompressor.finish();
+
+
+			if(useMT)
+				pThread_env->synchronize(NULL);
+		}
+
+		/* -------------------------------------------------------------------- */
+		/*      More general case - first pull into working buffer.             */
+		/* -------------------------------------------------------------------- */
+		else
+		{
+			GByte *pabyIntermediate = (GByte *)
+				VSIMalloc( dims.size.x * dims.size.y * nBandCount );
+			if( pabyIntermediate == NULL )
+			{
+				CPLError( CE_Failure, CPLE_OutOfMemory,
+					"Failed to allocate %d byte intermediate decompression buffer for jpeg2000.",
+					dims.size.x * dims.size.y * nBandCount );
+
+				return CE_Failure;
+			}
+
+			CPLDebug( "JP2KAK",
+				"DirectRasterIO() for %d,%d,%d,%d -> %dx%d -> %dx%d",
+				nXOff, nYOff, nXSize, nYSize,
+				dims.size.x, dims.size.y,
+				nBufXSize, nBufYSize );
+
+			kdu_stripe_decompressor decompressor;
+			decompressor.start(oCodeStream,false,false,useMT?pThread_env:NULL);
+
+			for( i = 0; i < nBandCount; i++ )
+				stripe_heights[i] = dims.size.y;
+
+			decompressor.pull_stripe( (kdu_byte *) pabyIntermediate,
+				stripe_heights );
+			decompressor.finish();
+
+
+			if(useMT)
+				pThread_env->synchronize(NULL);
+
+			/* -------------------------------------------------------------------- */
+			/*      Then resample (normally downsample) from the intermediate       */
+			/*      buffer into the final buffer in the desired output layout.      */
+			/* -------------------------------------------------------------------- */
+			int iY, iX;
+			double dfYRatio = dims.size.y / (double) nBufYSize;
+			double dfXRatio = dims.size.x / (double) nBufXSize;
+
+			for( iY = 0; iY < nBufYSize; iY++ )
+			{
+				int iSrcY = (int) floor( (iY + 0.5) * dfYRatio );
+
+				iSrcY = MIN(iSrcY, dims.size.y-1);
+
+				for( iX = 0; iX < nBufXSize; iX++ )
+				{
+					int iSrcX = (int) floor( (iX + 0.5) * dfXRatio );
+
+					iSrcX = MIN(iSrcX, dims.size.x-1);
+
+					for( i = 0; i < nBandCount; i++ )
+					{
+						((GByte *) pData)[iX*nPixelSpace
+							+ iY*nLineSpace
+							+ i*nBandSpace] =
+							pabyIntermediate[iSrcX*nBandCount
+							+ iSrcY*dims.size.x*nBandCount
+							+ i];
+					}
+				}
+			}
+
+			CPLFree( pabyIntermediate );
+		}
+	}
+	/* -------------------------------------------------------------------- */
+	/*      Catch internal Kakadu errors.                                    */
+	/* -------------------------------------------------------------------- */
+	catch( ... )
+	{
+		eErr = CE_Failure;
+	}
+
+	/* -------------------------------------------------------------------- */
+	/*      Cleanup                                                         */
+	/* -------------------------------------------------------------------- */
+	CPLFree( component_indices );
+	CPLFree( stripe_heights );
+
+	return eErr;
+}
+
+/************************************************************************/
+/*							prepareThreading                            */
+/************************************************************************/
+void JP2KAKDataset::prepareThreading(){
+	/* -------------------------------------------------------------------- */
+	/*      Multithreading Management                                       */
+	/* -------------------------------------------------------------------- */
+	//get the requested number of threads
+	//if this number is < 1 for us that means that we don't want to use any
+	//additional threads beyond the caller itself.
+	const int new_num_threads = atoi(CPLGetConfigOption("KAKADU_READ_MULTITHREADING_LEVEL","1"));
+	if(new_num_threads>1){
+		//we are requested to spawn at least one additional thread
+		int length=0;
+
+		//now, if we are requesting to use more threads than the ones we have we will ad them,
+		//if, on the other hand, we are requested to use less threads we have to first destroy
+		//the ones we have and recreate them
+		if(new_num_threads<num_threads)
+		{
+			if(pThread_env)
+			{
+				if(pThread_env->exists())
+					pThread_env->destroy();
+				delete pThread_env;
+			}
+			length=new_num_threads;
+		}
+		else
+			length=new_num_threads-num_threads;
+
+		//create the thread_env member in case we did not have one already
+		if(pThread_env==NULL)
+		{
+			pThread_env=new kdu_thread_env();
+			pThread_env->create();
+		}
+
+		//add to the thread_env member field as many threads as requested.
+		for (int k=1; k < length; k++)
+			if (pThread_env->add_thread())
+				num_threads++;
+			else
+				break;
+
+	}
+	else
+	{
+		//we do not want any multithreading
+		if(pThread_env)
+		{
+			num_threads=1;
+			if(pThread_env->exists())
+				pThread_env->destroy();
+			pThread_env=NULL;
+		}
+	}
+}
+/************************************************************************/
+/*                           TestUseBlockIO()                           */
+/*                                                                      */
+/*      Check whether we should use blocked IO (true) or direct io      */
+/*      (FALSE) for a given request configuration and environment.      */
+/************************************************************************/
+
+int
+JP2KAKDataset::TestUseBlockIO( int nXOff, int nYOff, int nXSize, int nYSize,
+							  int nBufXSize, int nBufYSize,
+							  GDALDataType eDataType,
+							  int nBandCount, int *panBandList )
+
+{
+	/* -------------------------------------------------------------------- */
+	/*      Due to limitations in DirectRasterIO() we can only handle       */
+	/*      8bit and with no duplicates in the band list.                   */
+	/* -------------------------------------------------------------------- */
+	if( eDataType != GDT_Byte
+		|| GetRasterBand(1)->GetRasterDataType() != GDT_Byte )
+		return TRUE;
+
+	int i, j;
+
+	for( i = 0; i < nBandCount; i++ )
+	{
+		for( j = i+1; j < nBandCount; j++ )
+			if( panBandList[j] == panBandList[i] )
+				return TRUE;
+	}
+
+	/* -------------------------------------------------------------------- */
+	/*      The rest of the rules are io strategy stuff, and use            */
+	/*      configuration checks.                                           */
+	/* -------------------------------------------------------------------- */
+	int bUseBlockedIO = bForceCachedIO;
+
+	if( nYSize == 1 || nXSize * ((double) nYSize) < 100.0 )
+		bUseBlockedIO = TRUE;
+
+	if( nBufYSize == 1 || nBufXSize * ((double) nBufYSize) < 100.0 )
+		bUseBlockedIO = TRUE;
+
+	if( bUseBlockedIO
+		&& CSLTestBoolean( CPLGetConfigOption( "GDAL_ONE_BIG_READ", "NO") ) )
+		bUseBlockedIO = FALSE;
+
+	return bUseBlockedIO;
+}
+
+/************************************************************************/
+/*                             IRasterIO()                              */
+/************************************************************************/
+
+CPLErr JP2KAKDataset::IRasterIO( GDALRWFlag eRWFlag,
+								int nXOff, int nYOff, int nXSize, int nYSize,
+								void * pData, int nBufXSize, int nBufYSize,
+								GDALDataType eBufType,
+								int nBandCount, int *panBandMap,
+								int nPixelSpace,int nLineSpace,int nBandSpace)
+
+{
+	/* -------------------------------------------------------------------- */
+	/*      We need various criteria to skip out to block based methods.    */
+	/* -------------------------------------------------------------------- */
+	if( TestUseBlockIO( nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize,
+		eBufType, nBandCount, panBandMap ) )
+		return GDALPamDataset::IRasterIO(
+		eRWFlag, nXOff, nYOff, nXSize, nYSize,
+		pData, nBufXSize, nBufYSize, eBufType,
+		nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace );
+	else
+		return DirectRasterIO(
+		eRWFlag, nXOff, nYOff, nXSize, nYSize,
+		pData, nBufXSize, nBufYSize, eBufType,
+		nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace );
+}
+
+/************************************************************************/
 /*                           transfer_bytes()                           */
 /*                                                                      */
 /*      Support function for JP2KAKRasterBand::ProcessTile().           */
@@ -1486,7 +1938,7 @@
         else if( eOutType == GDT_Int16 || eOutType == GDT_UInt16 )
         { // Transferring 32-bit absolute integers.
             kdu_int32 val;
-              
+
             for (; width > 0; width--, sp++, dest+=gap)
             {
                 val = sp->ival;
@@ -1566,7 +2018,7 @@
             {
                 kdu_int16 downshift = (kdu_int16) (precision-8);
                 kdu_int16 offset = (kdu_int16) ((1<<downshift)>>1);
-              
+
                 for (; width > 0; width--, sp++, dest+=gap)
                 {
                     val = sp->ival;
@@ -1610,21 +2062,21 @@
         return;
 
     memcpy( &nBoxType, poBox->GetType(), 4 );
-    
+
 /* -------------------------------------------------------------------- */
 /*      Write to a box on the JP2 file.                                 */
 /* -------------------------------------------------------------------- */
 #ifdef KAKADU4
     jp2_out->open_next( nBoxType );
 
-    jp2_out->write( (kdu_byte *) poBox->GetWritableData(), 
+    jp2_out->write( (kdu_byte *) poBox->GetWritableData(),
                     poBox->GetDataLength() );
 
     jp2_out->close();
 #else
     jp2_output_box &uuid_box = jp2_out->open_box( nBoxType );
 
-    uuid_box.write( (kdu_byte *) poBox->GetWritableData(), 
+    uuid_box.write( (kdu_byte *) poBox->GetWritableData(),
                     poBox->GetDataLength() );
 
     uuid_box.close();
@@ -1637,40 +2089,40 @@
 /*                     JP2KAKCreateCopy_WriteTile()                     */
 /************************************************************************/
 
-static int 
+static int
 JP2KAKCreateCopy_WriteTile( GDALDataset *poSrcDS, kdu_tile &oTile,
-                            kdu_roi_image *poROIImage, 
+                            kdu_roi_image *poROIImage,
                             int nXOff, int nYOff, int nXSize, int nYSize,
                             int bReversible, GDALDataType eType,
                             kdu_codestream &oCodeStream, int bFlushEnabled,
                             kdu_long *layer_bytes, int layer_count,
                             GDALProgressFunc pfnProgress, void * pProgressData,
-                            bool bComseg )
+                            bool bComseg,kdu_thread_env* pThreadEnv )
 
-{                                       
+{
 /* -------------------------------------------------------------------- */
 /*      Create one big tile, and a compressing engine, and line         */
 /*      buffer for each component.                                      */
 /* -------------------------------------------------------------------- */
-    int c, num_components = oTile.get_num_components(); 
+    int c, num_components = oTile.get_num_components();
     kdu_push_ifc  *engines = new kdu_push_ifc[num_components];
     kdu_line_buf  *lines = new kdu_line_buf[num_components];
     kdu_sample_allocator allocator;
     for (c=0; c < num_components; c++)
     {
-        kdu_resolution res = oTile.access_component(c).access_resolution(); 
+        kdu_resolution res = oTile.access_component(c).access_resolution();
         kdu_roi_node *roi_node = NULL;
 
         if( poROIImage != NULL )
         {
             kdu_dims  dims;
-            
+
             res.get_dims(dims);
             roi_node = poROIImage->acquire_node(c,dims);
         }
 
         lines[c].pre_create(&allocator,nXSize,bReversible,bReversible);
-        engines[c] = kdu_analysis(res,&allocator,bReversible,1.0F,roi_node);
+        engines[c] = kdu_analysis(res,&allocator,bReversible,1.0F,roi_node,pThreadEnv);
     }
 
     try
@@ -1682,11 +2134,11 @@
     }
     catch( ... )
     {
-        CPLError( CE_Failure, CPLE_AppDefined, 
+        CPLError( CE_Failure, CPLE_AppDefined,
                   "allocate.finalize() failed, likely out of memory for compression information." );
         return FALSE;
     }
-        
+
 /* -------------------------------------------------------------------- */
 /*      Write whole image.  Write 1024 lines of each component, then    */
 /*      go back to the first, and do again.  This gives the rate        */
@@ -1695,7 +2147,7 @@
     int  iLine, iLinesWritten = 0;
 #define CHUNK_SIZE  1024
 
-    GByte *pabyBuffer = (GByte *) 
+    GByte *pabyBuffer = (GByte *)
         CPLMalloc(nXSize * (GDALGetDataTypeSize(eType)/8) );
 
     CPLAssert( !oTile.get_ycc() );
@@ -1706,13 +2158,13 @@
         {
             GDALRasterBand *poBand = poSrcDS->GetRasterBand( c+1 );
             int iSubline = 0;
-        
-            for( iSubline = iLine; 
+
+            for( iSubline = iLine;
                  iSubline < iLine+CHUNK_SIZE && iSubline < nYSize;
                  iSubline++ )
             {
-                if( poBand->RasterIO( GF_Read, 
-                                      nXOff, nYOff+iSubline, nXSize, 1, 
+                if( poBand->RasterIO( GF_Read,
+                                      nXOff, nYOff+iSubline, nXSize, 1,
                                       (void *) pabyBuffer, nXSize, 1, eType,
                                       0, 0 ) == CE_Failure )
                     return FALSE;
@@ -1721,7 +2173,7 @@
                 {
                     kdu_sample16 *dest = lines[c].get_buf16();
                     kdu_byte *sp = pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
                         dest->ival = ((kdu_int16)(*sp)) - 128;
                 }
@@ -1729,7 +2181,7 @@
                 {
                     kdu_sample16 *dest = lines[c].get_buf16();
                     GInt16 *sp = (GInt16 *) pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
                         dest->ival = *sp;
                 }
@@ -1737,7 +2189,7 @@
                 {
                     kdu_sample16 *dest = lines[c].get_buf16();
                     GUInt16 *sp = (GUInt16 *) pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
                         dest->ival = *sp - 32767;
                 }
@@ -1745,43 +2197,43 @@
                 {
                     kdu_sample32 *dest = lines[c].get_buf32();
                     kdu_byte *sp = pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
-                        dest->fval = (float) 
+                        dest->fval = (float)
                             ((((kdu_int16)(*sp))-128.0) * 0.00390625);
                 }
                 else if( eType == GDT_Int16 )
                 {
                     kdu_sample32 *dest = lines[c].get_buf32();
                     GInt16  *sp = (GInt16 *) pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
-                        dest->fval = (float) 
+                        dest->fval = (float)
                             (((kdu_int16)(*sp)) * 0.0000152588);
                 }
                 else if( eType == GDT_UInt16 )
                 {
                     kdu_sample32 *dest = lines[c].get_buf32();
                     GUInt16  *sp = (GUInt16 *) pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
-                        dest->fval = (float) 
+                        dest->fval = (float)
                             (((int)(*sp) - 32768) * 0.0000152588);
                 }
                 else if( eType == GDT_Float32 )
                 {
                     kdu_sample32 *dest = lines[c].get_buf32();
                     float  *sp = (float *) pabyBuffer;
-                
+
                     for (int n=nXSize; n > 0; n--, dest++, sp++)
                         dest->fval = *sp;  /* scale it? */
                 }
 
-                engines[c].push(lines[c],true);
+                engines[c].push(lines[c],pThreadEnv);
 
                 iLinesWritten++;
 
-                if( !pfnProgress( iLinesWritten 
+                if( !pfnProgress( iLinesWritten
                                   / (double) (num_components * nYSize),
                                   NULL, pProgressData ) )
                 {
@@ -1790,17 +2242,23 @@
             }
         }
 
+		/************************************************************************/
+		/* Synchronize  prior to flushing                                       */
+		/************************************************************************/
+		if(pThreadEnv&&pThreadEnv->exists())
+			pThreadEnv->synchronize(NULL);
+
         if( oCodeStream.ready_for_flush() && bFlushEnabled )
         {
-            CPLDebug( "JP2KAK", 
+            CPLDebug( "JP2KAK",
                       "Calling oCodeStream.flush() at line %d",
                       MIN(nYSize,iLine+CHUNK_SIZE) );
-            
+
             oCodeStream.flush( layer_bytes, layer_count, NULL,
                                true, bComseg );
         }
         else if( bFlushEnabled )
-            CPLDebug( "JP2KAK", 
+            CPLDebug( "JP2KAK",
                       "read_for_flush() is false at line %d.",
                       iLine );
     }
@@ -1827,8 +2285,8 @@
 /************************************************************************/
 
 static GDALDataset *
-JP2KAKCreateCopy( const char * pszFilename, GDALDataset *poSrcDS, 
-                  int bStrict, char ** papszOptions, 
+JP2KAKCreateCopy( const char * pszFilename, GDALDataset *poSrcDS,
+                  int bStrict, char ** papszOptions,
                   GDALProgressFunc pfnProgress, void * pProgressData )
 
 {
@@ -1848,7 +2306,7 @@
 
         kdu_cpl_error_message oErrHandler( CE_Failure );
         kdu_cpl_error_message oWarningHandler( CE_Warning );
-        
+
         kdu_customize_warnings(new kdu_cpl_error_message( CE_Warning ) );
         kdu_customize_errors(new kdu_cpl_error_message( CE_Failure ) );
     }
@@ -1866,16 +2324,16 @@
     {
         if( bStrict )
         {
-            CPLError(CE_Failure, CPLE_AppDefined, 
+            CPLError(CE_Failure, CPLE_AppDefined,
                      "JP2KAK (JPEG2000) driver does not support data type %s.",
                      GDALGetDataTypeName( eType ) );
             return NULL;
         }
 
-        CPLError(CE_Warning, CPLE_AppDefined, 
+        CPLError(CE_Warning, CPLE_AppDefined,
                  "JP2KAK (JPEG2000) driver does not support data type %s, forcing to Float32.",
                  GDALGetDataTypeName( eType ) );
-        
+
         eType = GDT_Float32;
     }
 
@@ -1894,7 +2352,7 @@
         layer_count = atoi(CSLFetchNameValue(papszOptions,"LAYERS"));
     else if( CSLFetchNameValue(papszOptions,"Clayers") != NULL )
         layer_count = atoi(CSLFetchNameValue(papszOptions,"Clayers"));
-    
+
 /* -------------------------------------------------------------------- */
 /*	Establish how many bytes of data we want for each layer.  	*/
 /*	We take the quality as a percentage, so if QUALITY of 50 is	*/
@@ -1921,7 +2379,7 @@
 
     if( dfQuality < 99.5 )
     {
-        double dfLayerBytes = 
+        double dfLayerBytes =
             (nXSize * ((double) nYSize) * dfQuality / 100.0);
 
         dfLayerBytes *= (GDALGetDataTypeSize(eType) / 8);
@@ -1929,7 +2387,7 @@
 
         if( dfLayerBytes > 2000000000.0 && sizeof(kdu_long) == 4 )
         {
-            CPLError( CE_Warning, CPLE_AppDefined, 
+            CPLError( CE_Warning, CPLE_AppDefined,
                       "Trimmming maximum size of file 2GB from %.1fGB\n"
                       "to avoid overflow of kdu_long layer size.",
                       dfLayerBytes / 1000000000.0 );
@@ -1938,7 +2396,7 @@
 
         layer_bytes[layer_count-1] = (kdu_long) dfLayerBytes;
 
-        CPLDebug( "JP2KAK", "layer_bytes[] = %g\n", 
+        CPLDebug( "JP2KAK", "layer_bytes[] = %g\n",
                   (double) layer_bytes[layer_count-1] );
     }
     else
@@ -1987,7 +2445,7 @@
     {
         oSizeParams.set( Stiles, 0, 0, nTileYSize );
         oSizeParams.set( Stiles, 0, 1, nTileXSize );
-        
+
         CPLDebug( "JP2KAK", "Stiles=%d,%d", nTileYSize, nTileXSize );
     }
 
@@ -2058,7 +2516,7 @@
     kdu_roi_image  *poROIImage = NULL;
     char **papszROIDefs = CSLFetchNameValueMultiple( papszOptions, "ROI" );
     int iROI;
-    
+
     for( iROI = 0; papszROIDefs != NULL && papszROIDefs[iROI] != NULL; iROI++ )
     {
         kdu_dims region;
@@ -2068,7 +2526,7 @@
         if( CSLCount(papszTokens) != 4 )
         {
             CPLError( CE_Warning, CPLE_AppDefined,
-                      "Skipping corrupt ROI def = \n%s", 
+                      "Skipping corrupt ROI def = \n%s",
                       papszROIDefs[iROI] );
             continue;
         }
@@ -2083,49 +2541,54 @@
         poROIImage = new kdu_roi_rect(oCodeStream,region);
     }
 
-/* -------------------------------------------------------------------- */
-/*      Set some particular parameters.                                 */
-/* -------------------------------------------------------------------- */
-    oCodeStream.access_siz()->parse_string(
-        CPLSPrintf("Clayers=%d",layer_count));
-    oCodeStream.access_siz()->parse_string("Cycc=no");
-    if( eType == GDT_Int16 || eType == GDT_UInt16 )
-        oCodeStream.access_siz()->parse_string("Qstep=0.0000152588");
-        
-    if( bReversible )
-        oCodeStream.access_siz()->parse_string("Creversible=yes");
-    else
-        oCodeStream.access_siz()->parse_string("Creversible=no");
+	/* -------------------------------------------------------------------- */
+	/*      Set some particular parameters.                                 */
+	/* -------------------------------------------------------------------- */
+	    oCodeStream.access_siz()->parse_string(
+	        CPLSPrintf("Clayers=%d",layer_count));
 
-/* -------------------------------------------------------------------- */
-/*      Set some user-overridable parameters.                           */
-/* -------------------------------------------------------------------- */
-    int iParm;
-    char *apszParms[] = { "Corder", "PCRL", 
-                          "Cprecincts", "{512,512},{256,512},{128,512},{64,512},{32,512},{16,512},{8,512},{4,512},{2,512}",
-                          "ORGgen_plt", "yes", 
-                          "ORGgen_tlm", NULL,
-                          "Qguard", NULL, 
-                          "Cmodes", NULL, 
-                          "Clevels", NULL,
-                          "Cblk", NULL,
-                          "Rshift", NULL,
-                          "Rlevels", NULL,
-                          "Rweight", NULL,
-                          "Sprofile", NULL,
-                          NULL, NULL };
+	    if( bReversible )
+	        oCodeStream.access_siz()->parse_string("Creversible=yes");
+	    else
+	        oCodeStream.access_siz()->parse_string("Creversible=no");
 
+	/* -------------------------------------------------------------------- */
+	/*      Set some user-overridable parameters.                           */
+	/* -------------------------------------------------------------------- */
+	    int iParm;
+		/* ------------Adding Qstep parameter Management ---------------*/
+		char *pszQstep=NULL;
+		if( eType == GDT_Int16 || eType == GDT_UInt16 )
+			pszQstep= "0.0000152588";
+		/* -------------------------------------------------------------*/
+		char *apszParms[] = { "Corder", "PCRL",
+			"Cprecincts", "{512,512},{256,512},{128,512},{64,512},{32,512},{16,512},{8,512},{4,512},{2,512}",
+			"ORGgen_plt", "yes",
+			"ORGgen_tlm", NULL,
+			"ORGtparts", NULL,
+			"Qguard", NULL,
+			"Qstep", pszQstep,
+			"Cmodes", NULL,
+			"Clevels", NULL,
+			"Cblk", NULL,
+	        "Cycc", "no",
+			"Rshift", NULL,
+			"Rlevels", NULL,
+			"Rweight", NULL,
+			"Sprofile", NULL,
+		NULL, NULL };
+
     for( iParm = 0; apszParms[iParm] != NULL; iParm += 2 )
     {
-        const char *pszValue = 
+        const char *pszValue =
             CSLFetchNameValue( papszOptions, apszParms[iParm] );
-        
+
         if( pszValue == NULL )
             pszValue = apszParms[iParm+1];
 
         if( pszValue != NULL )
         {
-            const char *pszOpt = 
+            const char *pszOpt =
                 CPLSPrintf( "%s=%s", apszParms[iParm], pszValue );
             oCodeStream.access_siz()->parse_string( pszOpt );
 
@@ -2143,14 +2606,14 @@
         // Set dimensional information (all redundant with the SIZ marker segment)
         jp2_dimensions dims = jp2_out.access_dimensions();
         dims.init(&oSizeParams);
-        
+
         // Set colour space information (mandatory)
         jp2_colour colour = jp2_out.access_colour();
 
         if( bHaveCT || poSrcDS->GetRasterCount() == 3 )
             colour.init( JP2_sRGB_SPACE );
-        else if( poSrcDS->GetRasterCount() >= 4 
-                 && poSrcDS->GetRasterBand(4)->GetColorInterpretation() 
+        else if( poSrcDS->GetRasterCount() >= 4
+                 && poSrcDS->GetRasterBand(4)->GetColorInterpretation()
                  == GCI_AlphaBand )
         {
             colour.init( JP2_sRGB_SPACE );
@@ -2163,7 +2626,7 @@
             jp2_out.access_channels().set_opacity_mapping(2,3);
         }
         else if( poSrcDS->GetRasterCount() >= 2
-                 && poSrcDS->GetRasterBand(2)->GetColorInterpretation() 
+                 && poSrcDS->GetRasterBand(2)->GetColorInterpretation()
                  == GCI_AlphaBand )
         {
             colour.init( JP2_sLUM_SPACE );
@@ -2183,9 +2646,9 @@
         jp2_palette oJP2Palette;
         GDALColorTable *poCT = poPrototypeBand->GetColorTable();
         int  iColor, nCount = poCT->GetColorEntryCount();
-        kdu_int32 *panLUT = (kdu_int32 *) 
+        kdu_int32 *panLUT = (kdu_int32 *)
             CPLMalloc(sizeof(kdu_int32) * nCount * 3);
-        
+
         oJP2Palette = jp2_out.access_palette();
         oJP2Palette.init( 3, nCount );
 
@@ -2227,11 +2690,11 @@
     double	adfGeoTransform[6];
     if( bIsJP2
         && ((poSrcDS->GetGeoTransform(adfGeoTransform) == CE_None
-             && (adfGeoTransform[0] != 0.0 
-                 || adfGeoTransform[1] != 1.0 
-                 || adfGeoTransform[2] != 0.0 
-                 || adfGeoTransform[3] != 0.0 
-                 || adfGeoTransform[4] != 0.0 
+             && (adfGeoTransform[0] != 0.0
+                 || adfGeoTransform[1] != 1.0
+                 || adfGeoTransform[2] != 0.0
+                 || adfGeoTransform[3] != 0.0
+                 || adfGeoTransform[4] != 0.0
                  || ABS(adfGeoTransform[5]) != 1.0))
             || poSrcDS->GetGCPCount() > 0) )
     {
@@ -2248,7 +2711,7 @@
             oJP2MD.SetGeoTransform( adfGeoTransform );
         }
 
-        
+
         if( CSLFetchBoolean( papszOptions, "GMLJP2", TRUE ) )
             JP2KAKWriteBox( &jp2_out, oJP2MD.CreateGMLJP2(nXSize,nYSize) );
         if( CSLFetchBoolean( papszOptions, "GeoJP2", TRUE ) )
@@ -2259,7 +2722,7 @@
 /*      Do we have any XML boxes we want to preserve?                   */
 /* -------------------------------------------------------------------- */
     int iBox;
-    
+
     for( iBox = 0; TRUE; iBox++ )
     {
         CPLString oName;
@@ -2267,14 +2730,14 @@
 
         oName.Printf( "xml:BOX_%d", iBox );
         papszMD = poSrcDS->GetMetadata( oName );
-        
+
         if( papszMD == NULL || CSLCount(papszMD) != 1 )
             break;
 
         GDALJP2Box *poXMLBox = new GDALJP2Box();
 
         poXMLBox->SetType( "xml " );
-        poXMLBox->SetWritableData( strlen(papszMD[0])+1, 
+        poXMLBox->SetWritableData( strlen(papszMD[0])+1,
                                    (GByte *) papszMD[0] );
         JP2KAKWriteBox( &jp2_out, poXMLBox );
     }
@@ -2294,13 +2757,34 @@
     int iTileXOff, iTileYOff;
     double dfPixelsDone = 0.0;
     double dfPixelsTotal = nXSize * (double) nYSize;
-    
+
+    /* -------------------------------------------------------------------- */
+	/*					Multithreading Management                           */
+	/* We give the user the possibility to specify the number				*/
+	/* of threads for compressing the output dataset.						*/
+	/* -------------------------------------------------------------------- */
+	kdu_thread_env threadEnvW;
+	int numWriteThreads=0;
+	const int req_num_write_threads = atoi(CPLGetConfigOption("KAKADU_WRITE_MULTITHREADING_LEVEL","1"));
+
+	//WRITE
+	if(req_num_write_threads>1){
+		//creates the threading environment for compressing the output codestream
+		threadEnvW.create();
+		//add to the thread_env member field as many threads as requested.
+		for (int k=1; k <= req_num_write_threads; k++)
+			if (threadEnvW.add_thread())
+				numWriteThreads++;
+			else
+				break;
+	}
+
     for( iTileYOff = 0; iTileYOff < nYSize; iTileYOff += nTileYSize )
     {
         for( iTileXOff = 0; iTileXOff < nXSize; iTileXOff += nTileXSize )
         {
             kdu_tile oTile = oCodeStream.open_tile(
-                kdu_coords(iTileXOff/nTileXSize,iTileYOff/nTileYSize));
+                kdu_coords(iTileXOff/nTileXSize,iTileYOff/nTileYSize),numWriteThreads>0?&threadEnvW: NULL);
             int nThisTileXSize, nThisTileYSize;
 
             // ---------------------------------------------------------------
@@ -2309,7 +2793,7 @@
                 nThisTileXSize = nTileXSize;
             else
                 nThisTileXSize = nXSize - iTileXOff;
-    
+
             if( iTileYOff + nTileYSize < nYSize )
                 nThisTileYSize = nTileYSize;
             else
@@ -2319,25 +2803,47 @@
             // Setup scaled progress monitor
 
             void *pScaledProgressData;
-            double dfPixelsDoneAfter = 
+            double dfPixelsDoneAfter =
                 dfPixelsDone + (nThisTileXSize * (double) nThisTileYSize);
 
-            pScaledProgressData = 
+            pScaledProgressData =
                 GDALCreateScaledProgress( dfPixelsDone / dfPixelsTotal,
                                           dfPixelsDoneAfter / dfPixelsTotal,
                                           pfnProgress, pProgressData );
-            if( !JP2KAKCreateCopy_WriteTile( poSrcDS, oTile, poROIImage, 
-                                             iTileXOff, iTileYOff, 
-                                             nThisTileXSize, nThisTileYSize, 
+            if( !JP2KAKCreateCopy_WriteTile( poSrcDS, oTile, poROIImage,
+                                             iTileXOff, iTileYOff,
+                                             nThisTileXSize, nThisTileYSize,
                                              bReversible, eType,
                                              oCodeStream, bFlushEnabled,
                                              layer_bytes, layer_count,
-                                             GDALScaledProgress, 
-                                             pScaledProgressData, bComseg ) )
+                                             GDALScaledProgress,
+                                             pScaledProgressData, bComseg ,numWriteThreads>0?&threadEnvW:NULL) )
             {
                 GDALDestroyScaledProgress( pScaledProgressData );
 
+				/* -------------------------------------------------------------------- */
+				/*					Multithreading Management							*/
+				/*																		*/
+				/* If multi-threaded processing was used, we must now ensure that the	*/
+				/* local  stash of code buffers managed by each thread is returned to	*/
+				/* the codestream, before it is destroyed.   This is not necessary		*/
+				/* during decompression.												*/
+				/* -------------------------------------------------------------------- */
+				if (numWriteThreads>1&&threadEnvW.exists())
+					threadEnvW.terminate(NULL,true);
+
                 oCodeStream.destroy();
+                /* -------------------------------------------------------------------- */
+				/*					Multithreading Management                           */
+				/*								                                        */
+				/*								                                        */
+				/* Destroy the multithreading environment now that everything has been  */
+				/* written out.					                                        */
+				/* -------------------------------------------------------------------- */
+				if(numWriteThreads>1){
+					if(threadEnvW.exists())
+						threadEnvW.destroy();
+				}
                 poOutputFile->close();
                 VSIUnlink( pszFilename );
                 return NULL;
@@ -2346,16 +2852,39 @@
             GDALDestroyScaledProgress( pScaledProgressData );
             dfPixelsDone = dfPixelsDoneAfter;
 
-            oTile.close();
+            oTile.close(numWriteThreads>0?&threadEnvW: NULL);
         }
     }
-    
+
+    /* -------------------------------------------------------------------- */
+	/*					Multithreading Management							*/
+	/*																		*/
+	/* If multi-threaded processing was used, we must now ensure that the	*/
+	/* local  stash of code buffers managed by each thread is returned to	*/
+	/* the codestream, before it is destroyed.   This is not necessary		*/
+	/* during decompression.												*/
+	/* -------------------------------------------------------------------- */
+	if (numWriteThreads>1&&threadEnvW.exists())
+	threadEnvW.terminate(NULL,true);
+
 /* -------------------------------------------------------------------- */
 /*      Finish flushing out results.                                    */
 /* -------------------------------------------------------------------- */
-    oCodeStream.flush(layer_bytes, layer_count, NULL, true, bComseg );
+    oCodeStream.flush(layer_bytes, layer_count, NULL, true, bComseg,0,numWriteThreads>0?&threadEnvW: NULL );
     oCodeStream.destroy();
 
+	/* -------------------------------------------------------------------- */
+	/*					Multithreading Management                           */
+	/*								                                        */
+	/*								                                        */
+	/* Destroy the multithreading environment now that everything has been  */
+	/* written out.					                                        */
+	/* -------------------------------------------------------------------- */
+	if(numWriteThreads>1){
+		if(threadEnvW.exists())
+			threadEnvW.destroy();
+	}
+
     CPLFree( layer_bytes );
 
     if( bIsJP2 )
@@ -2376,7 +2905,7 @@
 /* -------------------------------------------------------------------- */
 /*      Re-open dataset, and copy any auxilary pam information.         */
 /* -------------------------------------------------------------------- */
-    GDALPamDataset *poDS = (GDALPamDataset *) 
+    GDALPamDataset *poDS = (GDALPamDataset *)
         GDALOpen( pszFilename, GA_ReadOnly );
 
     if( poDS )
@@ -2424,6 +2953,7 @@
 "   <Option name='Clevels' type='string'/>"
 "   <Option name='ORGgen_plt' type='string'/>"
 "   <Option name='ORGgen_tlm' type='string'/>"
+"   <Option name='ORGtparts' type='string'/>"
 "   <Option name='Qguard' type='integer'/>"
 "   <Option name='Sprofile' type='integer'/>"
 "   <Option name='Rshift' type='string'/>"
Index: swig/include/java/gdal_java.i
===================================================================
--- swig/include/java/gdal_java.i	(revision 13566)
+++ swig/include/java/gdal_java.i	(working copy)
@@ -92,3 +92,61 @@
 %}
 
 %include typemaps_java.i
+
+%extend GDALDatasetShadow {
+  CPLErr ReadRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Read, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0,0,0,0);
+
+}
+
+  CPLErr ReadRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, int bandsMap[], int pixelSpace, int lineSpace, int bandSpace, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Read, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, bandsMap, pixelSpace, lineSpace, bandSpace);
+
+}
+
+ CPLErr ReadRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, int pixelSpace, int lineSpace, int bandSpace, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Read, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0, pixelSpace, lineSpace, bandSpace);
+
+}
+
+ CPLErr WriteRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, void *buf)
+{
+  return GDALDatasetRasterIO( self, GF_Write, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0, 0, 0, 0);
+
+}
+
+  CPLErr WriteRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, int pixelSpace, int lineSpace, int bandSpace, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Write, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0, pixelSpace, lineSpace, bandSpace);
+
+}
+} /* extend */
+
+%extend  GDALMajorObjectShadow {
+  CPLErr SetMetadataItem( char * name , char * value, char * domain) {
+   return GDALSetMetadataItem( self, name, value, domain);
+  }
+} /* extend */
