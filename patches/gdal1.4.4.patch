Index: frmts/jp2kak/makefile.vc
===================================================================
--- frmts/jp2kak/makefile.vc	(revision 13622)
+++ frmts/jp2kak/makefile.vc	(working copy)
@@ -1,17 +1,34 @@
-
 GDAL_ROOT	=	..\..
 
 !INCLUDE $(GDAL_ROOT)\nmake.opt
 
 OBJ	=	jp2kakdataset.obj
-EXTRAFLAGS = 	-I$(KAKDIR) /DKDU_PENTIUM_MSVC /GX
 
+EXTRAFLAGS = 	-I$(KAKDIR) -I$(KAKDIR)\coresys\common -I$(KAKDIR)\apps\compressed_io \
+	-I$(KAKDIR)\apps\jp2 -I$(KAKDIR)\apps\image -I$(KAKDIR)\apps\args -I$(KAKDIR)\apps\support  /DKDU_PENTIUM_MSVC /GX
+
+APPOBJ  = $(KAKDIR)\apps\make\args.obj $(KAKDIR)\apps\make\image_in.obj \
+	$(KAKDIR)\apps\make\image_out.obj $(KAKDIR)\apps\make\jp2.obj \
+	$(KAKDIR)\apps\make\mj2.obj $(KAKDIR)\apps\make\palette.obj \
+	$(KAKDIR)\apps\make\roi_sources.obj
+
+# The following are just for Kakadu 5.1 or later.
+APPOBJ = $(KAKDIR)/apps/make/kdu_tiff.obj $(KAKDIR)/apps/make/jpx.obj $(KAKDIR)/apps/make/kdu_stripe_decompressor.obj $APPOBJ
+
 default:	$(OBJ) kakinstall
-	xcopy /D  /Y *.obj ..\o
+	copy *.obj ..\o
 
 kakinstall:
-	copy $(KAKDIR)\*.obj ..\o
+	copy $(KAKDIR)\apps\make\args.obj ..\o
+	copy $(KAKDIR)\apps\make\image_in.obj ..\o
+	copy $(KAKDIR)\apps\make\image_out.obj ..\o
+	copy $(KAKDIR)\apps\make\jp2.obj ..\o
+	copy $(KAKDIR)\apps\make\mj2.obj ..\o
+	copy $(KAKDIR)\apps\make\palette.obj ..\o
+	copy $(KAKDIR)\apps\make\roi_sources.obj ..\o
+	copy $(KAKDIR)\apps\make\kdu_tiff.obj ..\o
+	copy $(KAKDIR)\apps\make\jpx.obj ..\o
+	copy $(KAKDIR)\apps\make\kdu_stripe_decompressor.obj ..\o
 
 clean:
 	-del *.obj
-
Index: frmts/jp2kak/GNUmakefile
===================================================================
--- frmts/jp2kak/GNUmakefile	(revision 13622)
+++ frmts/jp2kak/GNUmakefile	(working copy)
@@ -10,7 +10,7 @@
 OBJ	=	jp2kakdataset.o
 
 KAKINC = -I$(KAKDIR)/coresys/common -I$(KAKDIR)/apps/compressed_io \
-	-I$(KAKDIR)/apps/jp2 -I$(KAKDIR)/apps/image -I$(KAKDIR)/apps/args 
+	-I$(KAKDIR)/apps/jp2 -I$(KAKDIR)/apps/image -I$(KAKDIR)/apps/args -I$(KAKDIR)/apps/support 
 
 APPOBJ  = $(KAK_OBJ)
 
Index: frmts/jp2kak/jp2kakdataset.cpp
===================================================================
--- frmts/jp2kak/jp2kakdataset.cpp	(revision 13622)
+++ frmts/jp2kak/jp2kakdataset.cpp	(working copy)
@@ -39,6 +39,7 @@
 #include "kdu_params.h"
 #include "kdu_compressed.h"
 #include "kdu_sample_processing.h"
+#include "kdu_stripe_decompressor.h"
 
 #ifdef FILEIO_DEBUG
 #include "dbg_file_source.h"
@@ -105,6 +106,8 @@
 
 class JP2KAKDataset : public GDALPamDataset
 {
+    friend class JP2KAKRasterBand;
+
     kdu_codestream oCodeStream;
     kdu_compressed_source *poInput;
     kdu_compressed_source *poRawInput;
@@ -113,6 +116,7 @@
 #endif
     kdu_client      *jpip_client;
     kdu_dims dims; 
+    int            nResCount;
 
     char	   *pszProjection;
     double	   adfGeoTransform[6];
@@ -123,6 +127,16 @@
 
     void           PamOverride();
 
+    int         TestUseBlockIO( int, int, int, int, int, int,
+                                GDALDataType, int, int * );
+    CPLErr      DirectRasterIO( GDALRWFlag, int, int, int, int,
+                                void *, int, int, GDALDataType,
+                                int, int *, int, int, int );
+
+    virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
+                              void *, int, int, GDALDataType,
+                              int, int *, int, int, int );
+
   public:
                 JP2KAKDataset();
 		~JP2KAKDataset();
@@ -165,6 +179,10 @@
     int         bYCbCrReported;
     
     GDALColorInterp eInterp;
+    
+    virtual CPLErr IRasterIO( GDALRWFlag, int, int, int, int,
+			void *, int, int, GDALDataType,
+		int, int );
 
   public:
 
@@ -488,6 +506,9 @@
 CPLErr JP2KAKRasterBand::IReadBlock( int nBlockXOff, int nBlockYOff,
                                       void * pImage )
 {
+    CPLDebug( "JP2KAK", "IReadBlock(%d,%d) on band %d.", 
+              nBlockXOff, nBlockYOff, nBand );
+
     try
     {
 /* -------------------------------------------------------------------- */
@@ -783,6 +804,36 @@
 }
 
 /************************************************************************/
+/*                             IRasterIO()                              */
+/************************************************************************/
+
+CPLErr
+JP2KAKRasterBand::IRasterIO( GDALRWFlag eRWFlag,
+							int nXOff, int nYOff, int nXSize, int nYSize,
+							void * pData, int nBufXSize, int nBufYSize,
+							GDALDataType eBufType,
+							int nPixelSpace,int nLineSpace )
+
+{
+	/* -------------------------------------------------------------------- */
+	/*      We need various criteria to skip out to block based methods.    */
+	/* -------------------------------------------------------------------- */
+	if( poBaseDS->TestUseBlockIO( nXOff, nYOff, nXSize, nYSize,
+		nBufXSize, nBufYSize,
+		eBufType, 1, &nBand ) )
+		return GDALPamRasterBand::IRasterIO(
+		eRWFlag, nXOff, nYOff, nXSize, nYSize,
+		pData, nBufXSize, nBufYSize, eBufType,
+		nPixelSpace, nLineSpace );
+	else
+		return poBaseDS->DirectRasterIO(
+		eRWFlag, nXOff, nYOff, nXSize, nYSize,
+		pData, nBufXSize, nBufYSize, eBufType,
+		1, &nBand, nPixelSpace, nLineSpace, 0 );
+
+}
+
+/************************************************************************/
 /*                            ApplyPalette()                            */
 /************************************************************************/
 
@@ -1242,8 +1293,24 @@
         poDS->poInput = poInput;
         poDS->poRawInput = poRawInput;
         poDS->oCodeStream.create( poInput );
-        poDS->oCodeStream.set_fussy();
-//        poDS->oCodeStream.set_resilient();
+        
+/************************************************************************/
+/*                  Managing custom error level                         */
+/************************************************************************/
+        if( CPLGetConfigOption("KAKADU_ERROR_LEVEL_MANAGEMENT",NULL)!=NULL)
+        {
+          const char *pszKduErrorManagement = CPLGetConfigOption(
+                                        "KAKADU_ERROR_LEVEL_MANAGEMENT","");
+          if(EQUAL(pszKduErrorManagement,"FUSSY"))
+            poDS->oCodeStream.set_fussy();
+          else if (EQUAL(pszKduErrorManagement,"RESILIENT"))
+            poDS->oCodeStream.set_resilient();
+          else if (EQUAL(pszKduErrorManagement,"FAST"))
+            poDS->oCodeStream.set_fast();
+        }
+        else
+          poDS->oCodeStream.set_fussy();
+      
         poDS->oCodeStream.set_persistent();
 
         poDS->jpip_client = jpip_client;
@@ -1428,6 +1495,261 @@
 }
 
 /************************************************************************/
+/*                           DirectRasterIO()                           */
+/************************************************************************/
+
+CPLErr 
+JP2KAKDataset::DirectRasterIO( GDALRWFlag eRWFlag,
+                               int nXOff, int nYOff, int nXSize, int nYSize,
+                               void * pData, int nBufXSize, int nBufYSize,
+                               GDALDataType eBufType, 
+                               int nBandCount, int *panBandMap,
+                               int nPixelSpace,int nLineSpace,int nBandSpace)
+    
+{
+    CPLAssert( eBufType == GDT_Byte );
+
+/* -------------------------------------------------------------------- */
+/*      Select optimal resolution level.                                */
+/* -------------------------------------------------------------------- */
+    int nDiscardLevels = 0;
+    int nResMult = 1;
+
+    while( nDiscardLevels < nResCount - 1 
+           && nBufXSize * nResMult * 2 < nXSize * 1.01
+           && nBufYSize * nResMult * 2 < nYSize * 1.01 )
+    {
+        nDiscardLevels++;
+        nResMult = nResMult * 2;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Prepare component indices list.                                 */
+/* -------------------------------------------------------------------- */
+    CPLErr eErr=CE_None;
+    int *component_indices;
+    int *stripe_heights, *sample_offsets, *sample_gaps, *row_gaps;
+    int i;
+    
+    component_indices = (int *) CPLMalloc(sizeof(int) * nBandCount);
+    stripe_heights = (int *) CPLMalloc(sizeof(int) * nBandCount);
+    sample_offsets = (int *) CPLMalloc(sizeof(int) * nBandCount);
+    sample_gaps = (int *) CPLMalloc(sizeof(int) * nBandCount);
+    row_gaps = (int *) CPLMalloc(sizeof(int) * nBandCount);
+
+    for( i = 0; i < nBandCount; i++ )
+        component_indices[i] = panBandMap[i] - 1;
+
+/* -------------------------------------------------------------------- */
+/*      Setup a ROI matching the block requested, and select desired    */
+/*      bands (components).                                             */
+/* -------------------------------------------------------------------- */
+    try
+    {
+        kdu_dims dims;
+        oCodeStream.apply_input_restrictions( 0, 0, nDiscardLevels, 0, NULL );
+        oCodeStream.get_dims( 0, dims );
+
+        dims.pos.x = dims.pos.x + nXOff/nResMult;
+        dims.pos.y = dims.pos.y + nYOff/nResMult;
+        dims.size.x = nXSize/nResMult;
+        dims.size.y = nYSize/nResMult;
+    
+        kdu_dims dims_roi;
+
+        oCodeStream.map_region( 0, dims, dims_roi );
+        oCodeStream.apply_input_restrictions( nBandCount, component_indices, 
+                                              nDiscardLevels, 0, &dims_roi,
+                                              KDU_WANT_CODESTREAM_COMPONENTS);
+
+/* -------------------------------------------------------------------- */
+/*      Special case where the data is being requested exactly at       */
+/*      this resolution.  Avoid any extra sampling pass.                */
+/* -------------------------------------------------------------------- */
+        if( nBufXSize == dims.size.x && nBufYSize == dims.size.y )
+        {
+            kdu_stripe_decompressor decompressor;
+            decompressor.start(oCodeStream);
+        
+            CPLDebug( "JP2KAK", "DirectRasterIO() for %d,%d,%d,%d -> %dx%d (no intermediate)",
+                      nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize );
+
+            for( i = 0; i < nBandCount; i++ )
+            {
+                stripe_heights[i] = dims.size.y;
+                sample_offsets[i] = i * nBandSpace;
+                sample_gaps[i] = nPixelSpace;
+                row_gaps[i] = nLineSpace;
+            }
+            
+            decompressor.pull_stripe( (kdu_byte *) pData, stripe_heights,
+                                      sample_offsets, sample_gaps, row_gaps );
+            decompressor.finish();
+        }
+
+/* -------------------------------------------------------------------- */
+/*      More general case - first pull into working buffer.             */
+/* -------------------------------------------------------------------- */
+        else
+        {
+            GByte *pabyIntermediate = (GByte *) 
+                VSIMalloc( dims.size.x * dims.size.y * nBandCount );
+            if( pabyIntermediate == NULL )
+            {
+                CPLError( CE_Failure, CPLE_OutOfMemory, 
+                          "Failed to allocate %d byte intermediate decompression buffer for jpeg2000.", 
+                          dims.size.x * dims.size.y * nBandCount );
+
+                return CE_Failure;
+            }
+
+            CPLDebug( "JP2KAK", 
+                      "DirectRasterIO() for %d,%d,%d,%d -> %dx%d -> %dx%d",
+                      nXOff, nYOff, nXSize, nYSize, 
+                      dims.size.x, dims.size.y, 
+                      nBufXSize, nBufYSize );
+
+            kdu_stripe_decompressor decompressor;
+            decompressor.start(oCodeStream);
+        
+            for( i = 0; i < nBandCount; i++ )
+                stripe_heights[i] = dims.size.y;
+            
+            decompressor.pull_stripe( (kdu_byte *) pabyIntermediate, 
+                                      stripe_heights );
+            decompressor.finish();
+
+/* -------------------------------------------------------------------- */
+/*      Then resample (normally downsample) from the intermediate       */
+/*      buffer into the final buffer in the desired output layout.      */
+/* -------------------------------------------------------------------- */
+            int iY, iX;
+            double dfYRatio = dims.size.y / (double) nBufYSize;
+            double dfXRatio = dims.size.x / (double) nBufXSize;
+
+            for( iY = 0; iY < nBufYSize; iY++ )
+            {
+                int iSrcY = (int) floor( (iY + 0.5) * dfYRatio );
+
+                iSrcY = MIN(iSrcY, dims.size.y-1);
+
+                for( iX = 0; iX < nBufXSize; iX++ )
+                {
+                    int iSrcX = (int) floor( (iX + 0.5) * dfXRatio );
+
+                    iSrcX = MIN(iSrcX, dims.size.x-1);
+
+                    for( i = 0; i < nBandCount; i++ )
+                    {
+                        ((GByte *) pData)[iX*nPixelSpace
+                                          + iY*nLineSpace
+                                          + i*nBandSpace] = 
+                            pabyIntermediate[iSrcX*nBandCount
+                                             + iSrcY*dims.size.x*nBandCount
+                                             + i];
+                    }
+                }
+            }
+
+            CPLFree( pabyIntermediate );
+        }
+    }
+/* -------------------------------------------------------------------- */
+/*      Catch interal Kakadu errors.                                    */
+/* -------------------------------------------------------------------- */
+    catch( ... )
+    {
+        eErr = CE_Failure;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      Cleanup                                                         */
+/* -------------------------------------------------------------------- */
+    CPLFree( component_indices );
+    CPLFree( stripe_heights );
+
+    return eErr;
+}
+
+/************************************************************************/
+/*                           TestUseBlockIO()                           */
+/*                                                                      */
+/*      Check whether we should use blocked IO (true) or direct io      */
+/*      (FALSE) for a given request configuration and environment.      */
+/************************************************************************/
+
+int 
+JP2KAKDataset::TestUseBlockIO( int nXOff, int nYOff, int nXSize, int nYSize,
+                               int nBufXSize, int nBufYSize,
+                               GDALDataType eDataType, 
+                               int nBandCount, int *panBandList )
+
+{
+/* -------------------------------------------------------------------- */
+/*      Due to limitations in DirectRasterIO() we can only handle       */
+/*      8bit and with no duplicates in the band list.                   */
+/* -------------------------------------------------------------------- */
+    if( eDataType != GDT_Byte 
+        || GetRasterBand(1)->GetRasterDataType() != GDT_Byte )
+        return TRUE;
+
+    int i, j; 
+    
+    for( i = 0; i < nBandCount; i++ )
+    {
+        for( j = i+1; j < nBandCount; j++ )
+            if( panBandList[j] == panBandList[i] )
+                return TRUE;
+    }
+
+/* -------------------------------------------------------------------- */
+/*      The rest of the rules are io strategy stuff, and use            */
+/*      configuration checks.                                           */
+/* -------------------------------------------------------------------- */
+    int bUseBlockedIO = bForceCachedIO;
+
+    if( nYSize == 1 || nXSize * ((double) nYSize) < 100.0 )
+        bUseBlockedIO = TRUE;
+
+    if( nBufYSize == 1 || nBufXSize * ((double) nBufYSize) < 100.0 )
+        bUseBlockedIO = TRUE;
+
+    if( bUseBlockedIO
+        && CSLTestBoolean( CPLGetConfigOption( "GDAL_ONE_BIG_READ", "NO") ) )
+        bUseBlockedIO = FALSE;
+
+    return bUseBlockedIO;
+}
+
+/************************************************************************/
+/*                             IRasterIO()                              */
+/************************************************************************/
+
+CPLErr JP2KAKDataset::IRasterIO( GDALRWFlag eRWFlag,
+                                 int nXOff, int nYOff, int nXSize, int nYSize,
+                                 void * pData, int nBufXSize, int nBufYSize,
+                                 GDALDataType eBufType, 
+                                 int nBandCount, int *panBandMap,
+                                 int nPixelSpace,int nLineSpace,int nBandSpace)
+
+{
+/* -------------------------------------------------------------------- */
+/*      We need various criteria to skip out to block based methods.    */
+/* -------------------------------------------------------------------- */
+    if( TestUseBlockIO( nXOff, nYOff, nXSize, nYSize, nBufXSize, nBufYSize,
+                        eBufType, nBandCount, panBandMap ) )
+        return GDALPamDataset::IRasterIO( 
+            eRWFlag, nXOff, nYOff, nXSize, nYSize,
+            pData, nBufXSize, nBufYSize, eBufType, 
+            nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace );
+    else
+        return DirectRasterIO( 
+            eRWFlag, nXOff, nYOff, nXSize, nYSize,
+            pData, nBufXSize, nBufYSize, eBufType, 
+            nBandCount, panBandMap, nPixelSpace, nLineSpace, nBandSpace );
+}
+
+/************************************************************************/
 /*                           transfer_bytes()                           */
 /*                                                                      */
 /*      Support function for JP2KAKRasterBand::ProcessTile().           */
@@ -2088,9 +2410,6 @@
 /* -------------------------------------------------------------------- */
     oCodeStream.access_siz()->parse_string(
         CPLSPrintf("Clayers=%d",layer_count));
-    oCodeStream.access_siz()->parse_string("Cycc=no");
-    if( eType == GDT_Int16 || eType == GDT_UInt16 )
-        oCodeStream.access_siz()->parse_string("Qstep=0.0000152588");
         
     if( bReversible )
         oCodeStream.access_siz()->parse_string("Creversible=yes");
@@ -2101,14 +2420,21 @@
 /*      Set some user-overridable parameters.                           */
 /* -------------------------------------------------------------------- */
     int iParm;
+    /* ------------Adding Qstep parameter Management ---------------*/
+    char *pszQstep=NULL;
+    if( eType == GDT_Int16 || eType == GDT_UInt16 )
+        pszQstep= "0.0000152588";
     char *apszParms[] = { "Corder", "PCRL", 
                           "Cprecincts", "{512,512},{256,512},{128,512},{64,512},{32,512},{16,512},{8,512},{4,512},{2,512}",
                           "ORGgen_plt", "yes", 
                           "ORGgen_tlm", NULL,
-                          "Qguard", NULL, 
+                          "ORGtparts", NULL,
+                          "Qguard", NULL,
+                          "Qstep", pszQstep, 
                           "Cmodes", NULL, 
                           "Clevels", NULL,
                           "Cblk", NULL,
+                          "Cycc", "no",
                           "Rshift", NULL,
                           "Rlevels", NULL,
                           "Rweight", NULL,
@@ -2422,8 +2748,10 @@
 "   <Option name='Cprecincts' type='string'/>"
 "   <Option name='Cmodes' type='string'/>"
 "   <Option name='Clevels' type='string'/>"
+"   <Option name='Cycc' type='string' description='defaults to no'/>"
 "   <Option name='ORGgen_plt' type='string'/>"
 "   <Option name='ORGgen_tlm' type='string'/>"
+"   <Option name='ORGtparts' type='string'/>"
 "   <Option name='Qguard' type='integer'/>"
 "   <Option name='Sprofile' type='integer'/>"
 "   <Option name='Rshift' type='string'/>"
Index: swig/include/java/gdal_java.i
===================================================================
--- swig/include/java/gdal_java.i	(revision 13622)
+++ swig/include/java/gdal_java.i	(working copy)
@@ -92,3 +92,62 @@
 %}
 
 %include typemaps_java.i
+
+%extend GDALDatasetShadow {
+  CPLErr ReadRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Read, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0,0,0,0);
+
+}
+
+  CPLErr ReadRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, int bandsMap[], int pixelSpace, int lineSpace, int bandSpace, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Read, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, bandsMap, pixelSpace, lineSpace, bandSpace);
+
+}
+
+ CPLErr ReadRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, int pixelSpace, int lineSpace, int bandSpace, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Read, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0, pixelSpace, lineSpace, bandSpace);
+
+}
+
+ CPLErr WriteRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, void *buf)
+{
+  return GDALDatasetRasterIO( self, GF_Write, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0, 0, 0, 0);
+
+}
+
+  CPLErr WriteRaster_Direct( int xoff, int yoff, int xsize, int ysize,
+                            int buf_xsize, int buf_ysize,
+                            GDALDataType buf_type, int bands, int pixelSpace, int lineSpace, int bandSpace, void *buf)
+{
+   return GDALDatasetRasterIO( self, GF_Write, xoff, yoff, xsize, ysize,
+                                 buf, buf_xsize, buf_ysize, 
+                                 buf_type, bands, 0, pixelSpace, lineSpace, bandSpace);
+
+}
+} /* extend */
+
+%extend  GDALMajorObjectShadow {
+  CPLErr SetMetadataItem( char * name , char * value, char * domain) {
+   return GDALSetMetadataItem( self, name, value, domain);
+  }
+} /* extend */
+
